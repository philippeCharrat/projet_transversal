C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE F0_M1
OBJECT MODULE PLACED IN .\Objects\F0_M1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE F0_M1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\F0_M1.lst) TABS(2) OBJECT(.\Objects\F0_M1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F0-M01.c
   3          //
   4          // Dernière Modification : 15/03/2021 (aucune erreur déclarées et 3 warnings) 
   5          // Auteur : 
   6          //  - Maxime LERICHE
   7          //  - Philippe CHARRAT
   8          // TODO : 
   9          //  - fonction d'erreur 
  10          //  - Convertion Struct to String 
  11          //  - 
  12          //-----------------------------------------------------------------------------
  13          
  14          // Import des bibliothèques ---
  15          #include <C8051F020.h>
  16          #include <stdio.h>
  17          #include <string.h>
  18          #include <stdlib.h>
  19          #include "c8051F020_SFR16.h"
  20          #include "MASTER_Config_Globale.h"
  21          #include "FO_M1__Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  22          #include "F0_M1.h"
  23          
  24          // ---
  25          
  26          // Prototypes de Fonctions  
  27          // Variables globales utiles
  28          char message_is_set;
  29          int commande_connue;
  30          char message_is_ready;
  31          int j,k,m,fin_commande;
  32          signed int i;
  33          
  34          // Variables char[] 
  35          char xdata buffer[5];
  36          char xdata strings[8];
  37          char xdata commande[35];
  38          char xdata params[15];
  39          char xdata message[35];
  40          char asuppr[15] = "Test";
  41          char* ptr_asuppr = &asuppr[0];
  42          
  43          // Variables pointeurs 
  44          char* ptrcommande; 
  45          char* ptrmessage;
  46          char* ptrbuffer;
  47          char* ptrstrings;
  48          
  49          struct argument_complexe args;
  50          struct  COMMANDES commandeenvoieStA;
  51          struct  INFORMATIONS informationenvoieAtS;
  52          
  53          char* split_element(char* ptr_commande) {
  54   1        // But : Récupérer un paramètre (plusieurs char) et les placer dans un tableau globale. La fonction va
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 2   

             - aussi passer un flag à 1 si la commande est finie ('\r'). 
  55   1        // Input : 
  56   1        //    - *ptr_commande : pointeur vers le buffer de la commande complète. 
  57   1        // Output : 
  58   1        //    - *ptr_commande : pointeur (incrémenté des m caractères parcourus) vers le buffer de la commande c
             -omplète. 
  59   1        m = 0;
  60   1        // Tant que le char n'est pas un espace 
  61   1        while( *ptr_commande != ' ') {
  62   2          // Cas : le char est la fin de la commande  
  63   2          if (*ptr_commande == '\r') {
  64   3            // flag de fin modifié
  65   3            fin_commande = 1;
  66   3            break;
  67   3            // Cas : char est "quelconque"
  68   3          } else {
  69   3            // Ajout dans le tableau params 
  70   3            params[m] = *ptr_commande;
  71   3            params[m+1] = '\0';
  72   3            m++;
  73   3            ptr_commande++;
  74   3          }
  75   2        }
  76   1        // Saut de l'espace 
  77   1        ptr_commande++;
  78   1        return ptr_commande; 
  79   1      }
  80          
  81          struct argument_complexe param_complexe(char* params) {
  82   1        // But : Convertir string en paramètres complexe, forme : param:valeur (exemple : A:12) 
  83   1        // Input : 
  84   1        //    - *param : pointeur vers la string paramètres 
  85   1        // Output : 
  86   1        //    - args : structure composée de deux champs :
  87   1        //          * param : nom du paramètre (1 char) 
  88   1        //          * valeur : entier 
  89   1        // Remarque : Si param plus de 1 char ? Idée : boucle jusqu'à ':'
  90   1        args.param = params[0];
  91   1        args.valeur = int_neg_or_positiv(2, params);
  92   1        return args;
  93   1      }
  94          
  95          int int_neg_or_positiv(int min, char* params) {
  96   1        // But : Gestion du signe pour la convertion str vers int : ['-','1','2'] => -12
  97   1        // Input : 
  98   1        //    - min : int pour indiquer le début du nombre
  99   1        //    - *param : pointeur vers la string contenat les chars 
 100   1        // Output : 
 101   1        //    - i : int signé 
 102   1        // Cas : int négatif 
 103   1        if (params[min] == '-') {
 104   2          // Récupération de sa valeur absolue 
 105   2          i = convertion_str_int(min+1, params);
 106   2          // Passage en négatif 
 107   2          i = 0-i;
 108   2          // Cas : int positif
 109   2        } else { i = convertion_str_int(min, params); }
 110   1        return i; 
 111   1      } 
 112          
 113          int convertion_str_int(int k, char* params) {
 114   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 3   

 115   1        // Input : 
 116   1        //    - k : int pour indiquer le début du nombre
 117   1        //    - *param : pointeur vers la string contenat les chars 
 118   1        // Output : 
 119   1        //    - atoi(buffer) : int non signé
 120   1        // Remarque : atoi() permet une convertion de char[] en int
 121   1        // Boucle jusqu'à 10 (valeur arbitraire) 
 122   1        for(j=k;j<10; j++){
 123   2          // Si le char est un digit
 124   2          if( params[j] == '1' || params[j] == '2'|| params[j] == '3'|| params[j] == '4'|| params[j] == '5'|| para
             -ms[j] == '6'|| params[j] == '7'|| params[j] == '8'|| params[j] == '9'|| params[j] == '0') {
 125   3            buffer[j-k]=params[j];
 126   3          }
 127   2          else { 
 128   3            buffer[j-k]='\0';
 129   3            break;
 130   3          }
 131   2        }
 132   1        return atoi(buffer);    
 133   1      }
 134          
 135          char* convertion_int_array(int i) {
 136   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 137   1        // Input : 
 138   1        //  - i : int 
 139   1        // Output : 
 140   1        //  - ptr : vers le buffer qui contient les chars
 141   1        k = 0;
 142   1      if (i/1000 != 0) { 
 143   2          buffer[k] = '0'+i/1000;
 144   2          k++;
 145   2          i = i-(i/1000)*1000;
 146   2        
 147   2        } else {
 148   2            buffer[k] = '0';
 149   2          k++;
 150   2        }
 151   1        if (i/100 != 0) { 
 152   2          buffer[k] = '0'+i/100;
 153   2          k++;
 154   2          i = i-(i/100)*100;
 155   2        } else {
 156   2            buffer[k] = '0';
 157   2          k++;
 158   2        } 
 159   1        if (i/10 != 0) { 
 160   2          buffer[k] = '0'+i/10;
 161   2          i = i-(i/10)*10;
 162   2          k++;
 163   2        } else {
 164   2            buffer[k] = '0';
 165   2          k++;
 166   2        }
 167   1        if (i != 0) { 
 168   2          buffer[k] = '0'+i;
 169   2          k++;
 170   2        } else {
 171   2            buffer[k] = '0';
 172   2          k++;
 173   2        }
 174   1        buffer[k] = '\0';
 175   1        return &buffer[0];
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 4   

 176   1      }
 177          
 178          char* ajout_char_array(char* ptrbuffer, char* ptrmessage) {
 179   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 180   1        // Input : 
 181   1        //    - *ptrmessage : pointeur vers le message
 182   1        //    - *ptrbuffer : pointeur vers le buffer de int
 183   1        // Output : 
 184   1        //    none
 185   1        while (1==1){
 186   2          // Si le char est un digit
 187   2          if( *ptrbuffer == '1' || *ptrbuffer == '2'|| *ptrbuffer == '3'|| *ptrbuffer == '4'|| *ptrbuffer == '5'||
             - *ptrbuffer == '6'|| *ptrbuffer == '7'|| *ptrbuffer == '8'|| *ptrbuffer == '9'|| *ptrbuffer == '0') {
 188   3            ptrmessage = ajout_char(ptrmessage, *ptrbuffer);
 189   3            ptrbuffer++;
 190   3          }
 191   2          else { 
 192   3            return ptrmessage;
 193   3          }
 194   2        }
 195   1      }
 196          
 197          char* ajout_char_string(char* ptrstrings, char* ptrmessage) {
 198   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 199   1        // Input : 
 200   1        //    - *ptrmessage : pointeur vers le message
 201   1        //    - *ptrbuffer : pointeur vers le buffer de int
 202   1        // Output : 
 203   1        //    none
 204   1        while (1==1){
 205   2          // Si le char est un digit
 206   2          if( *ptrstrings != '\0') {
 207   3            ptrmessage = ajout_char(ptrmessage, *ptrstrings);
 208   3            ptrstrings++;
 209   3          }
 210   2          else { 
 211   3            return ptrmessage;
 212   3          }
 213   2        }
 214   1      }
 215          
 216          char* ajout_char(char* ptrmessage, char c) {
 217   1        // But : Ajout d'un char sur message
 218   1        // Input : 
 219   1        //    - ptrmessage : pointeur vers le message
 220   1        //    - char : char à ajouter 
 221   1        // Output : 
 222   1        //    - ptrmessage : pointeur incrémenté
 223   1        *ptrmessage = c;
 224   1        ptrmessage++;
 225   1        //*ptrmessage = '\0';
 226   1        return ptrmessage;
 227   1      }
 228          
 229          //-----------------------------------------------------------------------------
 230          // Fonctions Convertion String vers Structure
 231          //-----------------------------------------------------------------------------
 232          
 233          struct COMMANDES Convertion_S_to_A(char * ptrcommande) {
 234   1        // But : Récupérer la partie commande et appeler les fonctions correspondante
 235   1        // Input : 
 236   1        //    none
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 5   

 237   1        // Output : 
 238   1        //    none
 239   1        // Remarque : strcmp() permet de chercher une suite de char dans un autre.
 240   1        // Remarque : A vérifier que je n'ai pas oublier de fonction comme le son ou MOU ... 
 241   1        
 242   1        // Récupération de la partie commande dans le tableau params
 243   1        ptrcommande = split_element(ptrcommande);
 244   1        commande_connue = 1;
 245   1        fin_commande = 0;
 246   1        
 247   1        // Test des différents cas de figures 
 248   1        if (params[0] == 'D' || params[0] == 'E' || params[0] == 'Q') {
 249   2            Convertion_Etat(params[0],ptrcommande);
 250   2        } else if (strcmp(params, "ASS") == 0) { 
 251   2            Convertion_Sonore(ptrcommande);
 252   2        } else if (strcmp(params, "MOB") == 0 ) {
 253   2            Convertion_Detection(ptrcommande);
 254   2        } else if (strcmp(params, "CS") == 0) {
 255   2            Convertion_Servomoteur(ptrcommande);
 256   2        } else if (strcmp(params, "MI") == 0 || strcmp(params, "ME") == 0 ) {
 257   2            if (strcmp(params, "MI") == 0) {  commandeenvoieStA.Etat_Energie = Mesure_I; }
 258   2            else { commandeenvoieStA.Etat_Energie = Mesure_E;}
 259   2        }else if (strcmp(params, "IPO") == 0 || strcmp(params, "POS") == 0) {
 260   2            Convertion_Coord(params,ptrcommande);
 261   2        } else if (strcmp(params, "L") == 0 || strcmp(params, "LS") == 0 ) {
 262   2            Convertion_Lumineux(params, ptrcommande);
 263   2        }else if (strcmp(params, "PPH") == 0 || strcmp(params, "SPH") == 0 ) {
 264   2            Convertion_Photo(params, ptrcommande);
 265   2        } else if (params[0] == 'A' || params[0] == 'B' || params[0] == 'S' || params[0] == 'G'|| strcmp(params, 
             -"RD") == 0 || strcmp(params, "RG") == 0 || strcmp(params, "RC") == 0 || strcmp(params, "RA") == 0|| strcmp(params, "TV")
             - == 0) { 
 266   2            Convertion_Mouvement(params,ptrcommande);
 267   2        } else {
 268   2            commande_connue = 0;
 269   2        }
 270   1        
 271   1        // Partie Réponse : 
 272   1        ptrmessage = &message[0];
 273   1        ptrmessage = ajout_char(ptrmessage, 0x0D);
 274   1        ptrmessage = ajout_char(ptrmessage, 0x0A);
 275   1        if (commande_connue == 1) { ptrmessage = ajout_char(ptrmessage, 0x3E);  }
 276   1        else {  ptrmessage = ajout_char(ptrmessage, 0x23); }
 277   1        ptrmessage = ajout_char(ptrmessage, '\r');
 278   1        ptrmessage = &message[0];
 279   1        return commandeenvoieStA;
 280   1      } 
 281             
 282          void Convertion_Etat(char etat, char* ptrcommande) {
 283   1        // But : Fonction pour les modifications de l'état d'épreuve
 284   1        // Input : 
 285   1        //    - etat : char qui définie l'état 
 286   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 287   1        // Output : 
 288   1        //    none
 289   1        // Cas D : Commencez étape 
 290   1          
 291   1        if (etat == 'D') {
 292   2          // Valeur par défaut 
 293   2          commandeenvoieStA.Etat_Epreuve = epreuve1;
 294   2          // Récupération et convertion de l'étape : 
 295   2          ptrcommande = split_element(ptrcommande);
 296   2          
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 6   

 297   2          i = int_neg_or_positiv(0,params);
 298   2          // Modification de la structure en fonction 
 299   2          if ( i == 1 ) { commandeenvoieStA.Etat_Epreuve = epreuve1;  }
 300   2          else if ( i == 2 ) {commandeenvoieStA.Etat_Epreuve = epreuve2;}
 301   2          else if ( i == 3 ) {commandeenvoieStA.Etat_Epreuve = epreuve3;}
 302   2          else if ( i == 4 ) {commandeenvoieStA.Etat_Epreuve = epreuve4;}
 303   2          else if ( i == 5 ) {commandeenvoieStA.Etat_Epreuve = epreuve5;}
 304   2          else if ( i == 6 ) {commandeenvoieStA.Etat_Epreuve = epreuve6;}
 305   2          else if ( i == 7 ) {commandeenvoieStA.Etat_Epreuve = epreuve7;}
 306   2          else if ( i == 8 ) {commandeenvoieStA.Etat_Epreuve = epreuve8;}
 307   2          // Cas E : Fin de l'épreuve 
 308   2        } else if (etat == 'E') {commandeenvoieStA.Etat_Epreuve = Fin_Epreuve; }
 309   1        // Cas Q : Arrêt de l'épreuve
 310   1        else { commandeenvoieStA.Etat_Epreuve = Stop_Urgence; }
 311   1      }
 312          
 313          void Convertion_Mouvement(char *mouvement, char* ptrcommande) {
 314   1        // But : Fonction de gestion des mouvements
 315   1        // Input : 
 316   1        //    - *mouvement : pointeur pour connaitre le type de mouvement 
 317   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 318   1        // Output : 
 319   1        //    none
 320   1        // Cas : Modification vitesse 
 321   1        if (strcmp(mouvement, "TV") == 0) {
 322   2                // Récupération du premier paramètre
 323   2              ptrcommande = split_element(ptrcommande);
 324   2              j = int_neg_or_positiv(0, params);
 325   2              if (j > 5 && j< 100) { 
 326   3                commandeenvoieStA.Vitesse = j;  
 327   3              }
 328   2        // Cas : Avancer ou reculer
 329   2        } else if (mouvement[0] == 'A'|| mouvement[0] == 'B') {
 330   2              // Modification de la structure avec l'action 
 331   2              if (mouvement[0] == 'A') { commandeenvoieStA.Etat_Mouvement = Avancer; }
 332   2              else { commandeenvoieStA.Etat_Mouvement = Reculer; }
 333   2              if (fin_commande == 0) {
 334   3                ptrcommande = split_element(ptrcommande);
 335   3                // Convertion du param
 336   3                j = int_neg_or_positiv(0, params);
 337   3                // Modification de la vitesse
 338   3                if (j > 5 && j<100) {commandeenvoieStA.Vitesse = j; }
 339   3              }
 340   2              if (commandeenvoieStA.Vitesse == 0) {commandeenvoieStA.Vitesse = 20;}
 341   2        // Cas : Stop le mouvement
 342   2        } else if (mouvement[0]== 'S') {
 343   2            commandeenvoieStA.Etat_Mouvement = Stopper;
 344   2        // Cas : Tourner à droite de 90° 
 345   2        } else if (strcmp(mouvement, "RD") == 0) {
 346   2            commandeenvoieStA.Etat_Mouvement = Rot_90D;
 347   2        // Cas : Tourner à gauche de 90°
 348   2        } else if (strcmp(mouvement, "RG") == 0) {
 349   2            commandeenvoieStA.Etat_Mouvement = Rot_90G;
 350   2        // Cas : Rotation de 180°
 351   2        } else if (strcmp(mouvement, "RC") == 0) {
 352   2            commandeenvoieStA.Etat_Mouvement = Rot_180D;
 353   2            if (fin_commande == 0) {
 354   3              ptrcommande = split_element(ptrcommande);
 355   3              // Cas : Droite 
 356   3              if (params[0] == 'D') { commandeenvoieStA.Etat_Mouvement = Rot_180D; }
 357   3              // Cas : Gauche
 358   3              else if (params[0] == 'G'){ commandeenvoieStA.Etat_Mouvement = Rot_180G; }
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 7   

 359   3            }
 360   2            // Cas : Rotation d'un angle
 361   2        } else if (strcmp(mouvement, "RA") == 0) {
 362   2              // Valeurs par défaut 
 363   2              commandeenvoieStA.Etat_Mouvement =Rot_AngD;
 364   2              commandeenvoieStA.Angle = 90; 
 365   2            if (fin_commande == 0) {
 366   3              ptrcommande = split_element(ptrcommande);
 367   3              // Convertion du param en struct
 368   3              if (params[1] == ':') {
 369   4                args = param_complexe(params);
 370   4                // Cas : Droite ou Gauche
 371   4                if (args.param == 'D') {commandeenvoieStA.Etat_Mouvement =Rot_AngD; }
 372   4                else if (args.param == 'G'){commandeenvoieStA.Etat_Mouvement =RotAngG;}
 373   4                // Ajout de l'angle
 374   4                commandeenvoieStA.Angle = args.valeur;
 375   4              }
 376   3            }
 377   2        } else if (strcmp(mouvement, "G") == 0) {
 378   2            while (fin_commande == 0) {
 379   3                // Récupérations et convertions des paramètres 
 380   3                ptrcommande = split_element(ptrcommande);
 381   3                // Si l'argument est complexe
 382   3                if (params[1] == ':') {
 383   4                  args = param_complexe(params);
 384   4                  // Différents cas possibles 
 385   4                  if ( args.param == 'X') {
 386   5                    if ( args.valeur > -99 && args.valeur < 99) {
 387   6                      commandeenvoieStA.Coord_X = args.valeur;
 388   6                    }
 389   5                  } else if ( args.param == 'Y') {
 390   5                    if ( args.valeur > -99 && args.valeur < 99) {
 391   6                      commandeenvoieStA.Coord_Y = args.valeur;
 392   6                    }
 393   5                  } else if ( args.param == 'A') {
 394   5                    if ( args.valeur > -180 && args.valeur < 180) {
 395   6                      commandeenvoieStA.Angle = args.valeur;
 396   6                    }
 397   5                  }
 398   4                }  // Sinon, ignoré  
 399   3            } 
 400   2        }
 401   1      }       
 402          
 403          
 404          void  Convertion_Sonore(char* ptrcommande){ 
 405   1        // But : Modification de l'état sonore
 406   1        // Input : 
 407   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 408   1        // Output : 
 409   1        //    none
 410   1        // Valeurs par défauts
 411   1        ptrcommande = split_element(ptrcommande);
 412   1            if (*ptrcommande == '0') { commandeenvoieStA.Etat_ACQ_Son = ACQ_non; }
 413   1            else {
 414   2              commandeenvoieStA.Etat_ACQ_Son = ACQ_oui;
 415   2                i = int_neg_or_positiv(0, params);
 416   2                if (i > 0 && i < 100) { commandeenvoieStA.ACQ_Duree = i; }
 417   2                else { commandeenvoieStA.ACQ_Duree = 99; }
 418   2            }
 419   1          }
 420          void Convertion_Detection(char* ptrcommande) {
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 8   

 421   1        // But : Fonction de gestion de la détection d'obstacle
 422   1        // Input : 
 423   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 424   1        // Output : 
 425   1        //    none
 426   1        // Valeurs par défauts
 427   1        commandeenvoieStA.DCT_Obst_Resolution = 30;
 428   1        commandeenvoieStA.Etat_DCT_Obst = oui_360;
 429   1        // Boucle des paramètres
 430   1        while (fin_commande == 0) {
 431   2          // Récupération du paramètre
 432   2          ptrcommande = split_element(ptrcommande);
 433   2          // Cas : Angle détection
 434   2          if( params[0] == '1' || params[0] == '0'|| params[0] == '2') {
 435   3            i = int_neg_or_positiv(0, params);
 436   3            if (i == 0) { commandeenvoieStA.Etat_DCT_Obst = DCT_non;}
 437   3            else if (i == 1) {commandeenvoieStA.Etat_DCT_Obst = oui_180;}
 438   3            else {commandeenvoieStA.Etat_DCT_Obst = oui_360;}
 439   3          }
 440   2          // Cas :Résolution angulaire
 441   2          if (params[0] == 'A' ) {
 442   3            args = param_complexe(params);
 443   3            if (args.valeur > 5 && args.valeur < 45) {commandeenvoieStA.DCT_Obst_Resolution = args.valeur;}
 444   3            else { commandeenvoieStA.DCT_Obst_Resolution = 30; }
 445   3          } 
 446   2        }
 447   1      }
 448          void Convertion_Servomoteur(char* ptrcommande) {  
 449   1        // But : Fonction de gestion des servomoteurs
 450   1        // Input : 
 451   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 452   1        // Output : 
 453   1        //    none
 454   1        // Valeurs par défauts
 455   1        commandeenvoieStA.Servo_Angle = 0;
 456   1        commandeenvoieStA.Etat_Servo = Servo_H;
 457   1        // Tant que l'on a des paramètres : 
 458   1        while (fin_commande == 0) {
 459   2          // Récupération des paramètres
 460   2          ptrcommande = split_element(ptrcommande);
 461   2          
 462   2          // Cas : Servomoteur Horizontale
 463   2          if (params[0] == 'H') { commandeenvoieStA.Etat_Servo = Servo_H; }
 464   2          // Cas : Servomoteur Verticale
 465   2          if (params[0] == 'V') { 
 466   3            commandeenvoieStA.Etat_Servo = Servo_V; }
 467   2          // Ajout de l'angle
 468   2          if (params[0] == 'A') {
 469   3            args = param_complexe(params);  
 470   3            commandeenvoieStA.Servo_Angle = args.valeur;
 471   3          }
 472   2        }
 473   1      }
 474          
 475          void Convertion_Coord(char* params,char* ptrcommande) { 
 476   1        // But : Fonction de gestion des coordonnées
 477   1        // Input : 
 478   1        //    - *params : pointeur vers le type de commande
 479   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 480   1        // Output : 
 481   1        //    none
 482   1        // Cas : Initialisation de coord
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 9   

 483   1        if (strcmp(params, "IPO") == 0) {
 484   2          // Valeurs par défaults
 485   2          commandeenvoieStA.Etat_Position = Init_Position;
 486   2          commandeenvoieStA.Pos_Angle = 0;
 487   2          // Boucle pour récupérer les paramètres
 488   2          while (fin_commande == 0) {
 489   3            // Récupération des paramètres
 490   3            ptrcommande = split_element(ptrcommande);
 491   3            args = param_complexe(params);
 492   3            // Différents cas : 
 493   3            if ( args.param == 'X') { commandeenvoieStA.Pos_Coord_X = args.valeur; } 
 494   3            if ( args.param == 'Y') { commandeenvoieStA.Pos_Coord_Y = args.valeur; }
 495   3            if ( args.param == 'A') { commandeenvoieStA.Pos_Angle = args.valeur; }
 496   3          }
 497   2          // Sinon : Récupération de coord
 498   2        } else {commandeenvoieStA.Etat_Position = Demande_Position;}      
 499   1      }
 500          
 501          void Convertion_Lumineux(char* params, char* ptrcommande) {
 502   1        // But : Fonction de gestion du pointeur lumineux
 503   1        // Input : 
 504   1        //    - *mouvement : pointeur pour connaitre le type de commandes 
 505   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 506   1        // Output : 
 507   1        //    none
 508   1        // Cas : Fin  
 509   1        if (strcmp(params, "LS") == 0) {
 510   2          commandeenvoieStA.Etat_Lumiere = Eteindre;
 511   2          // Cas : Initialisation 
 512   2        } else {
 513   2          // Valeurs par défaults
 514   2          commandeenvoieStA.Etat_Lumiere = Allumer;
 515   2          commandeenvoieStA.Lumiere_Intensite = 100;      
 516   2          commandeenvoieStA.Lumiere_Duree = 99;
 517   2          commandeenvoieStA.Lumire_Extinction = 0;
 518   2          commandeenvoieStA.Lumiere_Intensite = 1;
 519   2          // Boucle pour récupérer les paramètres 
 520   2          while (fin_commande == 0) {
 521   3            // Récupérations et convertions des paramètres 
 522   3            ptrcommande = split_element(ptrcommande);
 523   3            // Si l'argument est complexe
 524   3            if (params[1] == ':') {
 525   4              args = param_complexe(params);
 526   4              // Différents cas possibles 
 527   4              if ( args.param == 'I') {
 528   5                if ( args.valeur > 0 && args.valeur < 101) {
 529   6                  commandeenvoieStA.Lumiere_Intensite = args.valeur;
 530   6                }
 531   5              } else if ( args.param == 'D') {
 532   5                if ( args.valeur > 0 && args.valeur < 101) {
 533   6                  commandeenvoieStA.Lumiere_Duree = args.valeur;
 534   6                }
 535   5              } else if ( args.param == 'E') {
 536   5                if ( args.valeur > 0 && args.valeur < 101) {
 537   6                  commandeenvoieStA.Lumire_Extinction = args.valeur;
 538   6                }
 539   5              } else if ( args.param == 'N') {
 540   5                if ( args.valeur > 0 && args.valeur < 101) {
 541   6                  commandeenvoieStA.Lumiere_Nbre = args.valeur;
 542   6                }
 543   5              }
 544   4              
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 10  

 545   4            } // Sinon, ignoré
 546   3          }
 547   2        }
 548   1      }
 549          
 550          void Convertion_Photo(char* params, char* ptrcommande) {
 551   1        // But : Fonction de gestion des photos
 552   1        // Input : 
 553   1        //    - *params : pointeur pour connaitre le type de commandes 
 554   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 555   1        // Output : 
 556   1        //    none
 557   1        // Cas : Initialisation  
 558   1        if (strcmp(params, "PPH") == 0) {
 559   2          // Valeurs par défaut 
 560   2          commandeenvoieStA.Etat_Photo = Photo_1;
 561   2          commandeenvoieStA.Photo_Duree = 1;
 562   2          commandeenvoieStA.Photo_Nbre = 1;
 563   2          
 564   2          while (fin_commande == 0) {
 565   3            // Récupérations et convertions des paramètres 
 566   3            ptrcommande = split_element(ptrcommande);
 567   3            // Différents cas possibles 
 568   3            if ( params[0] == 'O') {
 569   4              commandeenvoieStA.Etat_Photo = Photo_1;
 570   4            }
 571   3            if ( params[0] == 'S') {
 572   4              commandeenvoieStA.Etat_Photo = Photo_Multiple; 
 573   4            }
 574   3            if ( params[0] == 'E') {
 575   4              args = param_complexe(params);
 576   4              commandeenvoieStA.Photo_Duree = args.valeur;
 577   4            }
 578   3            if ( params[0] == 'N') {
 579   4              args = param_complexe(params);
 580   4              commandeenvoieStA.Photo_Nbre = args.valeur;
 581   4            }
 582   3          }
 583   2          // Cas : Fin de photo
 584   2        } else {
 585   2            commandeenvoieStA.Etat_Photo = Photo_stop;
 586   2        }
 587   1      }
 588          
 589          //-----------------------------------------------------------------------------
 590          // Fonctions Convertion Structure vers String
 591          //-----------------------------------------------------------------------------
 592          
 593          char*  Convertion_A_to_S(struct INFORMATIONS informationenvoieAS) {
 594   1        // But : Convertion de la structure en string
 595   1        // Input : 
 596   1        //    none
 597   1        // Output : 
 598   1        //    none
 599   1        // Initialisation des variables
 600   1        message_is_set = 0;
 601   1        ptrmessage = &message[0];
 602   1        // Différents cas possible 
 603   1        // Si le message en lien avec l'état 
 604   1        if (informationenvoieAS.Etat_Invite == Invite_oui && message_is_set==0) {
 605   2          message_is_set= Convertion_Invite(ptrmessage); 
 606   2        }
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 11  

 607   1        // Si le message en lien avec l'arrivé
 608   1        if (informationenvoieAS.Etat_BUT_Mouvement == BUT_Atteint_oui && message_is_set==0) {
 609   2          message_is_set= Convertion_Arrive(ptrmessage); 
 610   2        }
 611   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Atteint_oui && message_is_set==0) {
 612   2          message_is_set= Convertion_Arrive_Servo(ptrmessage,informationenvoieAS); 
 613   2        }
 614   1        // Si le message en lien avec le courant
 615   1        if (informationenvoieAS.Etat_RESULT_Courant == RESULT_Courant_oui && message_is_set==0) {
 616   2          message_is_set=Convertion_Mesure('I',ptrmessage);
 617   2        }
 618   1        // Si le message en lien avec l'énergie
 619   1        if (informationenvoieAS.Etat_RESULT_Energie == RESULT_Energie_oui && message_is_set==0) {
 620   2          message_is_set=Convertion_Mesure('E',ptrmessage);
 621   2        }
 622   1        // Si le message en lien avec l'angle
 623   1        if (informationenvoieAS.Etat_RESULT_Position == RESULT_Position_oui && message_is_set==0) {
 624   2          
 625   2          message_is_set=Convertion_Position(ptrmessage, informationenvoieAS);
 626   2        }
 627   1        // Si le message est initialisé
 628   1        if (message_is_set==1) {
 629   2          ptrmessage = ajout_char(ptrmessage, '\r');
 630   2        }
 631   1        return &message[0];
 632   1      } 
 633          
 634          char Convertion_Invite(char *ptrmessage) {
 635   1        // But : Fonction Invité de Commande
 636   1        // Input : 
 637   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 638   1        // Output : 
 639   1        //    - char : pour vérifier le bo n déroulement 
 640   1        // Ajout de la partie Information 
 641   1        ptrmessage = ajout_char(ptrmessage, 'I');
 642   1        ptrmessage = ajout_char(ptrmessage, ' '); 
 643   1        // Boucle Tant que le message n'est pas finie  
 644   1        while(*informationenvoieAtS.MSG_Invit != '\0') {    
 645   2          ptrmessage = ajout_char(ptrmessage,*informationenvoieAtS.MSG_Invit);
 646   2        }
 647   1        return '1';
 648   1      }
 649          
 650          char Convertion_Arrive(char *ptrmessage) {
 651   1        // But : Fonction Arrivé 
 652   1        // Input : 
 653   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 654   1        // Output : 
 655   1        //    - char : pour vérifier le bon déroulement 
 656   1        // Ajout de la partie Information 
 657   1        ptrmessage = ajout_char(ptrmessage, 'B');
 658   1        return '1';
 659   1      }
 660          
 661          char Convertion_Arrive_Servo(char *ptrmessage, struct INFORMATIONS informationenvoieAS) {
 662   1        // But : Fonction Arrivé 
 663   1        // Input : 
 664   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 665   1        // Output : 
 666   1        //    - char : pour vérifier le bon déroulement 
 667   1        // Ajout de la partie Information 
 668   1        strcpy(strings,"ASS ");
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 12  

 669   1        ptrstrings = &strings[0];
 670   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 671   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Servo_V) {
 672   2          ptrmessage = ajout_char(ptrmessage, 'V');
 673   2        }
 674   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Servo_H) {
 675   2          ptrmessage = ajout_char(ptrmessage, 'H');
 676   2        }
 677   1        return '1';
 678   1      }
 679          
 680          char Convertion_Mesure(char type, char *ptrmessage) {
 681   1        // But : Fonction Mesure
 682   1        // Input : 
 683   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 684   1        // Output : 
 685   1        //    - char : pour vérifier le bo n déroulement 
 686   1        // Ajout de la partie Information 
 687   1        ptrmessage = ajout_char(ptrmessage, 'K');
 688   1        // Cas : Courant 
 689   1        if (type == 'I') {
 690   2          // Ajout de ' ' et valeur 
 691   2          ptrmessage = ajout_char(ptrmessage, type);
 692   2          ptrmessage = ajout_char(ptrmessage, ' ');
 693   2          ptrbuffer = convertion_int_array(informationenvoieAtS.Mesure_Courant);
 694   2          ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 695   2          return 1;
 696   2        }
 697   1        // Cas : Energie
 698   1        if (type == 'E') {
 699   2          // Ajout de ' ' et valeur 
 700   2          ptrmessage = ajout_char(ptrmessage, type);
 701   2          ptrmessage = ajout_char(ptrmessage, ' ');
 702   2          ptrbuffer = convertion_int_array(informationenvoieAtS.Mesure_Energie);
 703   2          ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 704   2          return 1;
 705   2        }
 706   1        ptrmessage--;
 707   1        return 0;
 708   1      }
 709          
 710          char Convertion_Info_Obstacle(char *ptrmessage) {
 711   1        // Todo :A comprendre mdrrrr
 712   1        ptrmessage++;
 713   1        return 1;
 714   1      }
 715          
 716          char Convertion_Position(char *ptrmessage, struct INFORMATIONS informationenvoieAS) {
 717   1        strcpy(strings," VPO X:\0");
 718   1        ptrstrings = &strings[0];
 719   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 720   1        ptrbuffer = convertion_int_array(informationenvoieAS.Pos_Coord_X);
 721   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 722   1        
 723   1        strcpy(strings," Y:\0");
 724   1        ptrstrings = &strings[0]; 
 725   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 726   1        ptrbuffer = convertion_int_array(informationenvoieAS.Pos_Coord_Y);
 727   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 728   1        
 729   1        strcpy(strings," A:\0");
 730   1        ptrstrings = &strings[0]; 
C51 COMPILER V9.60.0.0   F0_M1                                                             03/30/2021 17:39:39 PAGE 13  

 731   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 732   1        ptrbuffer = convertion_int_array(informationenvoieAS.Pos_Angle);
 733   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 734   1        return 1;
 735   1      }
 736          
 737          void prepare_message_random(void) {
 738   1        message_is_ready = 1;
 739   1        informationenvoieAtS.Etat_Invite = Invite_oui ;
 740   1        informationenvoieAtS.MSG_Invit = &ptr_asuppr;
*** WARNING C182 IN LINE 740 OF F0_M1.c: pointer to different objects
 741   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5284    ----
   CONSTANT SIZE    =     79    ----
   XDATA SIZE       =    198     155
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
