C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE F0_M1
OBJECT MODULE PLACED IN .\Objects\F0_M1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE F0_M1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\F0_M1.lst) TABS(2) OBJECT(.\Objects\F0_M1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F0-M01.c
   3          //
   4          // Dernière Modification : 15/03/2021 (aucune erreur déclarées et 3 warnings) 
   5          // Auteur : 
   6          //  - Maxime LERICHE
   7          //  - Philippe CHARRAT
   8          // TODO : 
   9          //  - fonction d'erreur 
  10          //  - Convertion Struct to String 
  11          //  - 
  12          //-----------------------------------------------------------------------------
  13          
  14          // Import des bibliothèques ---
  15          #include <C8051F020.h>
  16          #include <stdio.h>
  17          #include <string.h>
  18          #include <stdlib.h>
  19          #include "c8051F020_SFR16.h"
  20          #include "MASTER_Config_Globale.h"
  21          #include "FO_M1__Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  22          #include "F0_M1.h"
  23          
  24          // ---
  25          
  26          // Prototypes de Fonctions  
  27          // Variables globales utiles
  28          char message_is_set;
  29          int commande_connue;
  30          char message_is_ready;
  31          int j,k,m,fin_commande,analyse_commande;
  32          signed int i;
  33          char bit_reception_UART0;
  34          int iter_M1;
  35          
  36          // Variables char[] 
  37          char xdata buffer[5];
  38          char xdata strings[8];
  39          char xdata commandes_M1[35];
  40          char xdata commande[35];
  41          char xdata params[15];
  42          char xdata message[50];
  43          char xdata message_com[4];
  44          char asuppr[15] = "Test";
  45          char* ptr_asuppr = &asuppr[0];
  46          
  47          // Variables pointeurs 
  48          char* ptrcommande; 
  49          char* ptrcommandes_M1;
  50          char* ptrmessage;
  51          char* ptrbuffer;
  52          char* ptrstrings;
  53          char* ptr_Invite;
  54          
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 2   

  55          struct argument_complexe args;
  56          struct  COMMANDES commandeenvoieStA;
  57          struct  INFORMATIONS informationenvoieAtS;
  58          
  59          //-----------------------------------------------------------------------------
  60          // Fonctions UART et d'envoie
  61          //-----------------------------------------------------------------------------
  62          
  63          
  64          void Send_string_UART0(char* mot){
  65   1        // But : Fonction pour envoyer une string de manière automatique 
  66   1        // Input : 
  67   1        //    - mot : string avec les chars à envoyer (via pointeur)
  68   1        // Output : 
  69   1        //    none
  70   1        // Tant que le char n'est pas la fin de la commande ('\r') 
  71   1        while (*mot != '\0'){
  72   2          if(*(mot+1) == '\r'){ 
  73   3            Transmettre_UART0(*mot, 1); //Fin de chaine 
  74   3          } else { 
  75   3            Transmettre_UART0(*mot, 0); //milieu du mot
  76   3          }
  77   2          mot++;
  78   2        }
  79   1      }
  80          
  81          void Send_char_UART0(char c){
  82   1        // But : Fonction pour envoyer un caractère dans l'UART
  83   1        // Input : 
  84   1        //    - c : caractère à envoyer
  85   1        // Output : 
  86   1        //    none
  87   1        //Desactive reception
  88   1        REN0 = 0;
  89   1        SBUF0 = c;
  90   1        
  91   1        //Attente fin de transmission
  92   1        while(!TI0){}
  93   1          
  94   1        //Remise à 0 du flag d'envoi une fois qu'on est sur que le caractere a été transmis
  95   1        TI0 = 0;
  96   1        REN0 = 1;
  97   1      }
  98          
  99          void Transmettre_UART0(char caractere, bit LF){
 100   1        // But : Fonction pour envoyer un caractère et la 
 101   1        // Input : 
 102   1        //    - caractere : char à envoyer
 103   1        // Output : 
 104   1        //    none
 105   1        EA = 0;
 106   1        //desactive la reception
 107   1        REN0 = 0;
 108   1        
 109   1        //Ecrit la valeur dans SBUF0 pour transmettre
 110   1        SBUF0 = caractere;
 111   1        
 112   1        //Attente de la bonne transmission
 113   1        while(!TI0){}
 114   1          
 115   1        //Remise à 0 du flag d'envoi une fois qu'on est sur que le caractere a été transmis
 116   1        TI0 = 0;
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 3   

 117   1        REN0 = 1;
 118   1          
 119   1        if(LF){Transmettre_UART0(0x0D, 0);
 120   2        Transmettre_UART0(0x0A, 0);} //Retour à la ligne
 121   1        EA = 1;
 122   1      }
 123          
 124          char* split_element_M1(char* ptr_commande) {
 125   1        // But : Récupérer un paramètre (plusieurs char) et les placer dans un tableau globale. La fonction va
             - aussi passer un flag à 1 si la commande est finie ('\r'). 
 126   1        // Input : 
 127   1        //    - *ptr_commande : pointeur vers le buffer de la commande complète. 
 128   1        // Output : 
 129   1        //    - *ptr_commande : pointeur (incrémenté des m caractères parcourus) vers le buffer de la commande c
             -omplète. 
 130   1          m = 0;
 131   1        // Tant que le char n'est pas un espace 
 132   1        while( *ptr_commande != ' ') {
 133   2          // Cas : le char est la fin de la commande  
 134   2          if (*ptr_commande == '\r') {
 135   3            // flag de fin modifié
 136   3            fin_commande = 1;
 137   3            break;
 138   3            // Cas : char est "quelconque"
 139   3          } else {
 140   3            // Ajout dans le tableau params 
 141   3            params[m] = *ptr_commande;
 142   3            params[m+1] = '\0';
 143   3            m++;
 144   3            ptr_commande++;
 145   3          }
 146   2        }
 147   1        // Saut de l'espace 
 148   1        ptr_commande++;
 149   1        return ptr_commande; 
 150   1      }
 151          
 152          struct argument_complexe param_complexe(char* params) {
 153   1        // But : Convertir string en paramètres complexe, forme : param:valeur (exemple : A:12) 
 154   1        // Input : 
 155   1        //    - *param : pointeur vers la string paramètres 
 156   1        // Output : 
 157   1        //    - args : structure composée de deux champs :
 158   1        //          * param : nom du paramètre (1 char) 
 159   1        //          * valeur : entier 
 160   1        // Remarque : Si param plus de 1 char ? Idée : boucle jusqu'à ':'
 161   1        args.param = params[0];
 162   1        args.valeur = int_neg_or_positiv(2, params);
 163   1        return args;
 164   1      }
 165          
 166          int int_neg_or_positiv(int min, char* params) {
 167   1        // But : Gestion du signe pour la convertion str vers int : ['-','1','2'] => -12
 168   1        // Input : 
 169   1        //    - min : int pour indiquer le début du nombre
 170   1        //    - *param : pointeur vers la string contenat les chars 
 171   1        // Output : 
 172   1        //    - i : int signé 
 173   1        // Cas : int négatif 
 174   1        if (params[min] == '-') {
 175   2          // Récupération de sa valeur absolue 
 176   2          i = convertion_str_int_M1(min+1, params);
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 4   

 177   2          // Passage en négatif 
 178   2          i = 0-i;
 179   2          // Cas : int positif
 180   2        } else { i = convertion_str_int_M1(min, params); }
 181   1        return i; 
 182   1      } 
 183          
 184          int convertion_str_int_M1(int k, char* params) {
 185   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 186   1        // Input : 
 187   1        //    - k : int pour indiquer le début du nombre
 188   1        //    - *param : pointeur vers la string contenat les chars 
 189   1        // Output : 
 190   1        //    - atoi(buffer) : int non signé
 191   1        // Remarque : atoi() permet une convertion de char[] en int
 192   1        // Boucle jusqu'à 10 (valeur arbitraire) 
 193   1        for(j=k;j<10; j++){
 194   2          // Si le char est un digit
 195   2          if( params[j] == '1' || params[j] == '2'|| params[j] == '3'|| params[j] == '4'|| params[j] == '5'|| para
             -ms[j] == '6'|| params[j] == '7'|| params[j] == '8'|| params[j] == '9'|| params[j] == '0') {
 196   3            buffer[j-k]=params[j];
 197   3          }
 198   2          else { 
 199   3            buffer[j-k]='\0';
 200   3            break;
 201   3          }
 202   2        }
 203   1        return atoi(buffer);    
 204   1      }
 205          
 206          char* convertion_int_array_M1(int i) {
 207   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 208   1        // Input : 
 209   1        //  - i : int 
 210   1        // Output : 
 211   1        //  - ptr : vers le buffer qui contient les chars
 212   1        k = 0;
 213   1      if (i/1000 != 0) { 
 214   2          buffer[k] = '0'+i/1000;
 215   2          k++;
 216   2          i = i-(i/1000)*1000;
 217   2        
 218   2        } else {
 219   2            buffer[k] = '0';
 220   2          k++;
 221   2        }
 222   1        if (i/100 != 0) { 
 223   2          buffer[k] = '0'+i/100;
 224   2          k++;
 225   2          i = i-(i/100)*100;
 226   2        } else {
 227   2            buffer[k] = '0';
 228   2          k++;
 229   2        } 
 230   1        if (i/10 != 0) { 
 231   2          buffer[k] = '0'+i/10;
 232   2          i = i-(i/10)*10;
 233   2          k++;
 234   2        } else {
 235   2            buffer[k] = '0';
 236   2          k++;
 237   2        }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 5   

 238   1        if (i != 0) { 
 239   2          buffer[k] = '0'+i;
 240   2          k++;
 241   2        } else {
 242   2            buffer[k] = '0';
 243   2          k++;
 244   2        }
 245   1        buffer[k] = '\0';
 246   1        return &buffer[0];
 247   1      }
 248          
 249          char* ajout_char_array(char* ptrbuffer, char* ptrmessage) {
 250   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 251   1        // Input : 
 252   1        //    - *ptrmessage : pointeur vers le message
 253   1        //    - *ptrbuffer : pointeur vers le buffer de int
 254   1        // Output : 
 255   1        //    none
 256   1        while (1==1){
 257   2          // Si le char est un digit
 258   2          if( *ptrbuffer == '1' || *ptrbuffer == '2'|| *ptrbuffer == '3'|| *ptrbuffer == '4'|| *ptrbuffer == '5'||
             - *ptrbuffer == '6'|| *ptrbuffer == '7'|| *ptrbuffer == '8'|| *ptrbuffer == '9'|| *ptrbuffer == '0') {
 259   3            ptrmessage = ajout_char(ptrmessage, *ptrbuffer);
 260   3            ptrbuffer++;
 261   3          }
 262   2          else { 
 263   3            return ptrmessage;
 264   3          }
 265   2        }
 266   1      }
 267          
 268          char* ajout_char_string(char* ptrstrings, char* ptrmessage) {
 269   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 270   1        // Input : 
 271   1        //    - *ptrmessage : pointeur vers le message
 272   1        //    - *ptrbuffer : pointeur vers le buffer de int
 273   1        // Output : 
 274   1        //    none
 275   1        while (1==1){
 276   2          // Si le char est un digit
 277   2          if( *ptrstrings != '\0') {
 278   3            ptrmessage = ajout_char(ptrmessage, *ptrstrings);
 279   3            ptrstrings++;
 280   3          }
 281   2          else { 
 282   3            return ptrmessage;
 283   3          }
 284   2        }
 285   1      }
 286          
 287          char* ajout_char(char* ptrmessage, char c) {
 288   1        // But : Ajout d'un char sur message
 289   1        // Input : 
 290   1        //    - ptrmessage : pointeur vers le message
 291   1        //    - char : char à ajouter 
 292   1        // Output : 
 293   1        //    - ptrmessage : pointeur incrémenté
 294   1        *ptrmessage = c;
 295   1        ++ptrmessage;
 296   1        //*ptrmessage = '\0';
 297   1        return ptrmessage;
 298   1      }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 6   

 299          
 300          struct COMMANDES recuperation_structure_commande(struct COMMANDES pCommandeenvoieStA){
 301   1        // But : Récupération de la structure commande dans le mains 
 302   1        // Input : 
 303   1        //    - pCommandeenvoieStA  : Une structure de la commande avec les anciennes instructions
 304   1        // Output : 
 305   1        //    - pCommandeenvoieStA  : Une structure de la commande avec les nouvelles instructions
 306   1        // Partie Réception 
 307   1        if (RI0 == 1){
 308   2          commandeenvoieStA = pCommandeenvoieStA;
 309   2          RI0 = 0;
 310   2          REN0 = 0;
 311   2          // Récupération du char dans le buffer
 312   2          bit_reception_UART0 = SBUF0;
 313   2          // Ajout du char dans la string commande 
 314   2          commandes_M1[iter_M1] = bit_reception_UART0;
 315   2          commandes_M1[iter_M1+1] = '\0';
 316   2          Send_char_UART0(bit_reception_UART0);
 317   2          // Incrément du tab commande
 318   2          iter_M1++;
 319   2          // Si fin de commande 
 320   2          if (bit_reception_UART0 == '\r'){
 321   3            // Affichage en console
 322   3            Send_string_UART0("Commande recue : ");
 323   3            Send_string_UART0(commandes_M1);
 324   3            ptrcommandes_M1 = &commandes_M1[0];
 325   3            
 326   3            // Convertion de commande vers struct
 327   3            pCommandeenvoieStA = Convertion_S_to_A(ptrcommandes_M1);
 328   3            iter_M1 = 0;
 329   3          }
 330   2        }
 331   1        return pCommandeenvoieStA;
 332   1      }
 333          
 334          //-----------------------------------------------------------------------------
 335          // Fonctions Convertion String vers Structure
 336          //-----------------------------------------------------------------------------
 337          
 338          struct COMMANDES Convertion_S_to_A(char * ptrcommande) {
 339   1        // But : Récupérer la partie commande et appeler les fonctions correspondante
 340   1        // Input : 
 341   1        //    none
 342   1        // Output : 
 343   1        //    none
 344   1        // Remarque : strcmp() permet de chercher une suite de char dans un autre.
 345   1        // Remarque : A vérifier que je n'ai pas oublier de fonction comme le son ou MOU ... 
 346   1        
 347   1        // Récupération de la partie commande dans le tableau params
 348   1        ptrcommande = split_element_M1(ptrcommande);
 349   1        commande_connue = 1;
 350   1        fin_commande = 0;
 351   1        analyse_commande = 0;
 352   1        
 353   1        // Test des différents cas de figures 
 354   1        if (params[0] == 'D' || params[0] == 'E' || params[0] == 'Q') {
 355   2            Convertion_Etat(params[0],ptrcommande);
 356   2        } else if (strcmp(params, "ASS") == 0) { 
 357   2            Convertion_Sonore(ptrcommande);
 358   2        } else if (strcmp(params, "MOB") == 0 || strcmp(params, "MOS") == 0 || strcmp(params, "MOU") == 0) {
 359   2            Convertion_Detection(ptrcommande);
 360   2        } else if (strcmp(params, "CS") == 0) {
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 7   

 361   2            Convertion_Servomoteur(ptrcommande);
 362   2        } else if (strcmp(params, "MI") == 0 || strcmp(params, "ME") == 0 ) {
 363   2            if (strcmp(params, "MI") == 0) {  commandeenvoieStA.Etat_Energie = Mesure_I; }
 364   2            else { commandeenvoieStA.Etat_Energie = Mesure_E;}
 365   2        } else if (strcmp(params, "IPO") == 0 || strcmp(params, "POS") == 0) {
 366   2            Convertion_Coord(params,ptrcommande);
 367   2        } else if (strcmp(params, "L") == 0 || strcmp(params, "LS") == 0 ) {
 368   2            Convertion_Lumineux(params, ptrcommande);
 369   2        }else if (strcmp(params, "PPH") == 0 || strcmp(params, "SPH") == 0 ) {
 370   2            Convertion_Photo(params, ptrcommande);
 371   2        } else if (params[0] == 'A' || params[0] == 'B' || params[0] == 'S' || strcmp(params, "RD") == 0 || strcm
             -p(params, "RG") == 0 || strcmp(params, "RC") == 0 || strcmp(params, "RA") == 0|| strcmp(params, "TV") == 0) {
 372   2          if (commandeenvoieStA.Etat_Mouvement != Depl_Coord){
 373   3            Convertion_Mouvement(params,ptrcommande);}
 374   2        } else if (params[0] == 'G'){
 375   2            Convertion_Coord_Init(ptrcommande);
 376   2        } else {
 377   2            commande_connue = 0;
 378   2        }
 379   1        
 380   1        // Partie Réponse : 
 381   1        memset(message_com,0,10);
 382   1        ptrmessage = &message_com[0];
 383   1        ptrmessage = ajout_char(ptrmessage, 0x0D);
 384   1        ptrmessage = ajout_char(ptrmessage, 0x0A);
 385   1        if (commande_connue == 1) { ptrmessage = ajout_char(ptrmessage, 0x3E);  }
 386   1        else {  ptrmessage = ajout_char(ptrmessage, 0x23); }
 387   1        ptrmessage = ajout_char(ptrmessage, '\r');
 388   1        Send_string_UART0(&message_com[0]);
 389   1          
 390   1        return commandeenvoieStA;
 391   1      } 
 392             
 393          void Convertion_Etat(char etat, char* ptrcommande) {
 394   1        // But : Fonction pour les modifications de l'état d'épreuve
 395   1        // Input : 
 396   1        //    - etat : char qui définie l'état 
 397   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 398   1        // Output : 
 399   1        //    none
 400   1        // Cas D : Commencez étape 
 401   1          
 402   1        if (etat == 'D') {
 403   2          // Valeur par défaut 
 404   2          commandeenvoieStA.Etat_Epreuve = epreuve1;
 405   2          // Récupération et convertion de l'étape : 
 406   2          ptrcommande = split_element_M1(ptrcommande);
 407   2          
 408   2          i = int_neg_or_positiv(0,params);
 409   2          // Modification de la structure en fonction 
 410   2          if ( i == 1 ) { commandeenvoieStA.Etat_Epreuve = epreuve1;  }
 411   2          else if ( i == 2 ) {commandeenvoieStA.Etat_Epreuve = epreuve2;}
 412   2          else if ( i == 3 ) {commandeenvoieStA.Etat_Epreuve = epreuve3;}
 413   2          else if ( i == 4 ) {commandeenvoieStA.Etat_Epreuve = epreuve4;}
 414   2          else if ( i == 5 ) {commandeenvoieStA.Etat_Epreuve = epreuve5;}
 415   2          else if ( i == 6 ) {commandeenvoieStA.Etat_Epreuve = epreuve6;}
 416   2          else if ( i == 7 ) {commandeenvoieStA.Etat_Epreuve = epreuve7;}
 417   2          else if ( i == 8 ) {commandeenvoieStA.Etat_Epreuve = epreuve8;}
 418   2          // Cas E : Fin de l'épreuve 
 419   2        } else if (etat == 'E') {commandeenvoieStA.Etat_Epreuve = Fin_Epreuve; }
 420   1        // Cas Q : Arrêt de l'épreuve
 421   1        else { commandeenvoieStA.Etat_Epreuve = Stop_Urgence; }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 8   

 422   1      }
 423          
 424          void Convertion_Mouvement(char *mouvement, char* ptrcommande) {
 425   1        // But : Fonction de gestion des mouvements
 426   1        // Input : 
 427   1        //    - *mouvement : pointeur pour connaitre le type de mouvement 
 428   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 429   1        // Output : 
 430   1        //    none
 431   1        // Cas : Modification vitesse 
 432   1        if (strcmp(mouvement, "TV") == 0) {
 433   2                // Récupération du premier paramètre
 434   2              ptrcommande = split_element_M1(ptrcommande);
 435   2              j = int_neg_or_positiv(0, params);
 436   2              if (j > 5 && j< 100) { 
 437   3                commandeenvoieStA.Vitesse = j;  
 438   3              }
 439   2        // Cas : Avancer ou reculer
 440   2        } else if (mouvement[0] == 'A'|| mouvement[0] == 'B') {
 441   2              // Modification de la structure avec l'action 
 442   2              if (mouvement[0] == 'A') { commandeenvoieStA.Etat_Mouvement = Avancer; }
 443   2              else { commandeenvoieStA.Etat_Mouvement = Reculer; }
 444   2              if (fin_commande == 0) {
 445   3                ptrcommande = split_element_M1(ptrcommande);
 446   3                // Convertion du param
 447   3                j = int_neg_or_positiv(0, params);
 448   3                // Modification de la vitesse
 449   3                if (j > 5 && j<100) {commandeenvoieStA.Vitesse = j; }
 450   3              }
 451   2              if (commandeenvoieStA.Vitesse == 0) {commandeenvoieStA.Vitesse = 20;}
 452   2        // Cas : Stop le mouvement
 453   2        } else if (mouvement[0]== 'S') {
 454   2            commandeenvoieStA.Etat_Mouvement = Stopper;
 455   2        // Cas : Tourner à droite de 90° 
 456   2        } else if (strcmp(mouvement, "RD") == 0) {
 457   2            commandeenvoieStA.Etat_Mouvement = Rot_90D;
 458   2        // Cas : Tourner à gauche de 90°
 459   2        } else if (strcmp(mouvement, "RG") == 0) {
 460   2            commandeenvoieStA.Etat_Mouvement = Rot_90G;
 461   2        // Cas : Rotation de 180°
 462   2        } else if (strcmp(mouvement, "RC") == 0) {
 463   2            commandeenvoieStA.Etat_Mouvement = Rot_180D;
 464   2            if (fin_commande == 0) {
 465   3              ptrcommande = split_element_M1(ptrcommande);
 466   3              // Cas : Droite 
 467   3              if (params[0] == 'D') { commandeenvoieStA.Etat_Mouvement = Rot_180D; }
 468   3              // Cas : Gauche
 469   3              else if (params[0] == 'G'){ commandeenvoieStA.Etat_Mouvement = Rot_180G; }
 470   3            }
 471   2            // Cas : Rotation d'un angle
 472   2        } else if (strcmp(mouvement, "RA") == 0) {
 473   2              // Valeurs par défaut 
 474   2              commandeenvoieStA.Etat_Mouvement =Rot_AngD;
 475   2              commandeenvoieStA.Angle = 90; 
 476   2            if (fin_commande == 0) {
 477   3              ptrcommande = split_element_M1(ptrcommande);
 478   3              // Convertion du param en struct
 479   3              if (params[1] == ':') {
 480   4                args = param_complexe(params);
 481   4                // Cas : Droite ou Gauche
 482   4                if (args.param == 'D') {commandeenvoieStA.Etat_Mouvement =Rot_AngD; }
 483   4                else if (args.param == 'G'){commandeenvoieStA.Etat_Mouvement =Rot_AngG;}
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 9   

 484   4                // Ajout de l'angle
 485   4                commandeenvoieStA.Angle = args.valeur;
 486   4            }
 487   3          }
 488   2        } 
 489   1      }     
 490          
 491          void Convertion_Coord_Init(char* ptrcommande) {
 492   1        // But : Modification de l'état sonore
 493   1        // Input : 
 494   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 495   1        // Output : 
 496   1        //    none
 497   1        // Modification de la structure
 498   1        commandeenvoieStA.Etat_Mouvement =Depl_Coord;
 499   1        while (fin_commande == 0) {
 500   2          // Récupérations et convertions des paramètres 
 501   2          ptrcommande = split_element_M1(ptrcommande);
 502   2          // Si l'argument est complexe
 503   2          if (params[1] == ':') { 
 504   3            args = param_complexe(params);
 505   3            // Différents cas possibles 
 506   3            if ( args.param == 'X') {
 507   4              if ( args.valeur > -99 && args.valeur < 99) {
 508   5                commandeenvoieStA.Coord_X = args.valeur;
 509   5              }
 510   4            } else if ( args.param == 'Y') {
 511   4              if ( args.valeur > -99 && args.valeur < 99) {
 512   5                commandeenvoieStA.Coord_Y = args.valeur;
 513   5              }
 514   4            } else if ( args.param == 'A') {
 515   4              if ( args.valeur > -180 && args.valeur < 180) {
 516   5                commandeenvoieStA.Angle = args.valeur;
 517   5              }
 518   4            }
 519   3          }
 520   2        } 
 521   1      }
 522          
 523          void  Convertion_Sonore(char* ptrcommande){ 
 524   1        // But : Modification de l'état sonore
 525   1        // Input : 
 526   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 527   1        // Output : 
 528   1        //    none
 529   1        // Valeurs par défauts
 530   1        ptrcommande = split_element_M1(ptrcommande);
 531   1            if (*ptrcommande == '0') { commandeenvoieStA.Etat_ACQ_Son = ACQ_non; }
 532   1            else {
 533   2              commandeenvoieStA.Etat_ACQ_Son = ACQ_oui;
 534   2                i = int_neg_or_positiv(0, params);
 535   2                if (i > 0 && i < 100) { commandeenvoieStA.ACQ_Duree = i; }
 536   2                else { commandeenvoieStA.ACQ_Duree = 99; }
 537   2            }
 538   1          }
 539          void Convertion_Detection(char* ptrcommande) {
 540   1        // But : Fonction de gestion de la détection d'obstacle
 541   1        // Input : 
 542   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 543   1        // Output : 
 544   1        //    none
 545   1        // Valeurs par défauts
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 10  

 546   1          if (params[2] == 'U') {
 547   2          commandeenvoieStA.Etat_DCT_Obst =oui_180_unique;
 548   2          ptrcommande = split_element_M1(ptrcommande);
 549   2          if (params[0] == '2') {
 550   3            commandeenvoieStA.Etat_DCT_Obst =oui_360_unique;
 551   3          }
 552   2        }
 553   1        else if (params[2] == 'B') {
 554   2          commandeenvoieStA.DCT_Obst_Resolution = 30;
 555   2          commandeenvoieStA.Etat_DCT_Obst = oui_360;
 556   2          // Boucle des paramètres
 557   2          while (fin_commande == 0) {
 558   3            // Récupération du paramètre
 559   3            ptrcommande = split_element_M1(ptrcommande);
 560   3            // Cas : Angle détection
 561   3            if( params[0] == '1' || params[0] == '0'|| params[0] == '2') {
 562   4              i = int_neg_or_positiv(0, params);
 563   4              if (i == 0) { commandeenvoieStA.Etat_DCT_Obst = DCT_non;}
 564   4              else if (i == 1) {commandeenvoieStA.Etat_DCT_Obst = oui_180;}
 565   4              else {commandeenvoieStA.Etat_DCT_Obst = oui_360;}
 566   4            }
 567   3            // Cas :Résolution angulaire
 568   3            if (params[0] == 'A' ) {
 569   4              args = param_complexe(params);
 570   4              if (args.valeur > 5 && args.valeur < 45) {commandeenvoieStA.DCT_Obst_Resolution = args.valeur;}
 571   4              else { commandeenvoieStA.DCT_Obst_Resolution = 30; }
 572   4            } 
 573   3          }
 574   2        } else if (params[2] == 'S') {
 575   2          commandeenvoieStA.DCT_Obst_Resolution = 30;
 576   2          commandeenvoieStA.Etat_DCT_Obst = oui_360_proche;
 577   2          // Boucle des paramètres
 578   2          while (fin_commande == 0) {
 579   3            // Récupération du paramètre
 580   3            ptrcommande = split_element_M1(ptrcommande);
 581   3            // Cas : Angle détection
 582   3            if( params[0] == '1' || params[0] == '0'|| params[0] == '2') {
 583   4              i = int_neg_or_positiv(0, params);
 584   4              if (i == 0) { commandeenvoieStA.Etat_DCT_Obst = DCT_non;}
 585   4              else if (i == 1) {commandeenvoieStA.Etat_DCT_Obst = oui_180_proche;}
 586   4              else {commandeenvoieStA.Etat_DCT_Obst = oui_360_proche;}
 587   4            }
 588   3            // Cas :Résolution angulaire
 589   3            if (params[0] == 'A' ) {
 590   4              args = param_complexe(params);
 591   4              if (args.valeur > 5 && args.valeur < 45) {commandeenvoieStA.DCT_Obst_Resolution = args.valeur;}
 592   4              else { commandeenvoieStA.DCT_Obst_Resolution = 30; }
 593   4            } 
 594   3          }
 595   2        }
 596   1      }
 597          void Convertion_Servomoteur(char* ptrcommande) {  
 598   1        // But : Fonction de gestion des servomoteurs
 599   1        // Input : 
 600   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 601   1        // Output : 
 602   1        //    none
 603   1        // Valeurs par défauts
 604   1        commandeenvoieStA.Servo_Angle = 0;
 605   1        commandeenvoieStA.Etat_Servo = Servo_H;
 606   1        // Tant que l'on a des paramètres : 
 607   1        while (fin_commande == 0) {
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 11  

 608   2          // Récupération des paramètres
 609   2          ptrcommande = split_element_M1(ptrcommande);
 610   2          
 611   2          // Cas : Servomoteur Horizontale
 612   2          if (params[0] == 'H') { commandeenvoieStA.Etat_Servo = Servo_H; }
 613   2          // Cas : Servomoteur Verticale
 614   2          if (params[0] == 'V') { 
 615   3            commandeenvoieStA.Etat_Servo = Servo_V; }
 616   2          // Ajout de l'angle
 617   2          if (params[0] == 'A') {
 618   3            args = param_complexe(params);  
 619   3            commandeenvoieStA.Servo_Angle = args.valeur;
 620   3          }
 621   2        }
 622   1      }
 623          
 624          void Convertion_Coord(char* params,char* ptrcommande) { 
 625   1        // But : Fonction de gestion des coordonnées
 626   1        // Input : 
 627   1        //    - *params : pointeur vers le type de commande
 628   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 629   1        // Output : 
 630   1        //    none
 631   1        // Cas : Initialisation de coord
 632   1        if (strcmp(params, "IPO") == 0) {
 633   2          // Valeurs par défaults
 634   2          commandeenvoieStA.Etat_Position = Init_Position;
 635   2          commandeenvoieStA.Pos_Angle = 0;
 636   2          // Boucle pour récupérer les paramètres
 637   2          while (fin_commande == 0) {
 638   3            // Récupération des paramètres
 639   3            ptrcommande = split_element_M1(ptrcommande);
 640   3            args = param_complexe(params);
 641   3            // Différents cas : 
 642   3            if ( args.param == 'X') { commandeenvoieStA.Pos_Coord_X = args.valeur; } 
 643   3            if ( args.param == 'Y') { commandeenvoieStA.Pos_Coord_Y = args.valeur; }
 644   3            if ( args.param == 'A') { commandeenvoieStA.Pos_Angle = args.valeur; }
 645   3          }
 646   2          // Sinon : Récupération de coord
 647   2        } else {commandeenvoieStA.Etat_Position = Demande_Position;}      
 648   1      }
 649          
 650          void Convertion_Lumineux(char* params, char* ptrcommande) {
 651   1        // But : Fonction de gestion du pointeur lumineux
 652   1        // Input : 
 653   1        //    - *mouvement : pointeur pour connaitre le type de commandes_M1 
 654   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 655   1        // Output : 
 656   1        //    none
 657   1        // Cas : Fin  
 658   1        if (strcmp(params, "LS") == 0) {
 659   2          commandeenvoieStA.Etat_Lumiere = Eteindre;
 660   2          // Cas : Initialisation 
 661   2        } else {
 662   2          // Valeurs par défaults
 663   2          commandeenvoieStA.Etat_Lumiere = Allumer;
 664   2          commandeenvoieStA.Lumiere_Intensite = 100;      
 665   2          commandeenvoieStA.Lumiere_Duree = 99;
 666   2          commandeenvoieStA.Lumire_Extinction = 0;
 667   2          commandeenvoieStA.Lumiere_Intensite = 1;
 668   2          // Boucle pour récupérer les paramètres 
 669   2          while (fin_commande == 0) {
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 12  

 670   3            // Récupérations et convertions des paramètres 
 671   3            ptrcommande = split_element_M1(ptrcommande);
 672   3            // Si l'argument est complexe
 673   3            if (params[1] == ':') {
 674   4              args = param_complexe(params);
 675   4              // Différents cas possibles 
 676   4              if ( args.param == 'I') {
 677   5                if ( args.valeur > 0 && args.valeur < 101) {
 678   6                  commandeenvoieStA.Lumiere_Intensite = args.valeur;
 679   6                }
 680   5              } else if ( args.param == 'D') {
 681   5                if ( args.valeur > 0 && args.valeur < 101) {
 682   6                  commandeenvoieStA.Lumiere_Duree = args.valeur;
 683   6                }
 684   5              } else if ( args.param == 'E') {
 685   5                if ( args.valeur > 0 && args.valeur < 101) {
 686   6                  commandeenvoieStA.Lumire_Extinction = args.valeur;
 687   6                }
 688   5              } else if ( args.param == 'N') {
 689   5                if ( args.valeur > 0 && args.valeur < 101) {
 690   6                  commandeenvoieStA.Lumiere_Nbre = args.valeur;
 691   6                }
 692   5              }
 693   4              
 694   4            } // Sinon, ignoré
 695   3          }
 696   2        }
 697   1      }
 698          
 699          void Convertion_Photo(char* params, char* ptrcommande) {
 700   1        // But : Fonction de gestion des photos
 701   1        // Input : 
 702   1        //    - *params : pointeur pour connaitre le type de commandes_M1 
 703   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 704   1        // Output : 
 705   1        //    none
 706   1        // Cas : Initialisation  
 707   1        if (strcmp(params, "PPH") == 0) {
 708   2          // Valeurs par défaut 
 709   2          commandeenvoieStA.Etat_Photo = Photo_1;
 710   2          commandeenvoieStA.Photo_Duree = 1;
 711   2          commandeenvoieStA.Photo_Nbre = 1;
 712   2          
 713   2          while (fin_commande == 0) {
 714   3            // Récupérations et convertions des paramètres 
 715   3            ptrcommande = split_element_M1(ptrcommande);
 716   3            // Différents cas possibles 
 717   3            if ( params[0] == 'O') {
 718   4              commandeenvoieStA.Etat_Photo = Photo_1;
 719   4            }
 720   3            if ( params[0] == 'S') {
 721   4              commandeenvoieStA.Etat_Photo = Photo_Multiple; 
 722   4            }
 723   3            if ( params[0] == 'E') {
 724   4              args = param_complexe(params);
 725   4              commandeenvoieStA.Photo_Duree = args.valeur;
 726   4            }
 727   3            if ( params[0] == 'N') {
 728   4              args = param_complexe(params);
 729   4              commandeenvoieStA.Photo_Nbre = args.valeur;
 730   4            }
 731   3          }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 13  

 732   2          // Cas : Fin de photo
 733   2        } else {
 734   2            commandeenvoieStA.Etat_Photo = Photo_stop;
 735   2        }
 736   1      }
 737          
 738          //-----------------------------------------------------------------------------
 739          // Fonctions Convertion Structure vers String
 740          //-----------------------------------------------------------------------------
 741          
 742          void Convertion_A_to_S(struct INFORMATIONS informationenvoieAS) {
 743   1        // But : Convertion de la structure en string
 744   1        // Input : 
 745   1        //    none
 746   1        // Output : 
 747   1        //    none
 748   1        // Initialisation des variables
 749   1        message_is_set = 0;
 750   1        memset(message,0,30);
 751   1        ptrmessage = &message[0];
 752   1        // Différents cas possible 
 753   1        // Si le message en lien avec l'état 
 754   1        if (informationenvoieAS.Etat_Invite == Invite_oui && message_is_set==0) {
 755   2          message_is_set= Convertion_Invite(ptrmessage,informationenvoieAS);
 756   2          
 757   2        }
 758   1        // Si le message en lien avec l'arrivé
 759   1        if (informationenvoieAS.Etat_BUT_Mouvement == BUT_Atteint_oui && message_is_set==0) {
 760   2          message_is_set= Convertion_Arrive(ptrmessage); 
 761   2        }
 762   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Atteint_oui && message_is_set==0) {
 763   2          message_is_set= Convertion_Arrive_Servo(ptrmessage,informationenvoieAS); 
 764   2        }
 765   1        // Si le message en lien avec le courant
 766   1        if (informationenvoieAS.Etat_RESULT_Courant == RESULT_Courant_oui && message_is_set==0) {
 767   2          message_is_set=Convertion_Mesure('I',ptrmessage);
 768   2        }
 769   1        // Si le message en lien avec l'énergie
 770   1        if (informationenvoieAS.Etat_RESULT_Energie == RESULT_Energie_oui && message_is_set==0) {
 771   2          message_is_set=Convertion_Mesure('E',ptrmessage);
 772   2        }
 773   1        // Si le message en lien avec l'angle
 774   1        if (informationenvoieAS.Etat_RESULT_Position == RESULT_Position_oui && message_is_set==0) {
 775   2          
 776   2          message_is_set=Convertion_Position(ptrmessage, informationenvoieAS);
 777   2        }
 778   1        // Si le message est initialisé
 779   1        if (message_is_set=='1') {
 780   2          ptrmessage = ajout_char(ptrmessage, '\n');
 781   2          ptrmessage = ajout_char(ptrmessage, '\r');
 782   2          Send_string_UART0(&message[0]);
 783   2        }
 784   1      } 
 785          
 786          char Convertion_Invite(char *ptrmessage,struct INFORMATIONS informationenvoieAS) {
 787   1        // But : Fonction Invité de Commande
 788   1        // Input : 
 789   1        //    - *ptrmessage : pointeur vers le char[] pour le message
 790   1        // Output : 
 791   1        //    - char : pour vérifier le bodéroulement 
 792   1        // Ajout de la partie Information 
 793   1        ptrmessage = ajout_char(ptrmessage, 'I');
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 14  

 794   1        ptrmessage = ajout_char(ptrmessage, ' '); 
 795   1        strcat(message,informationenvoieAS.MSG_Invit);
 796   1        
 797   1        
 798   1        return '1';
 799   1      }
 800          
 801          char Convertion_Arrive(char *ptrmessage) {
 802   1        // But : Fonction Arrivé 
 803   1        // Input : 
 804   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 805   1        // Output : 
 806   1        //    - char : pour vérifier le bon déroulement 
 807   1        // Ajout de la partie Information 
 808   1        ptrmessage = ajout_char(ptrmessage, 'B');
 809   1        return '1';
 810   1      }
 811          
 812          char Convertion_Arrive_Servo(char *ptrmessage, struct INFORMATIONS informationenvoieAS) {
 813   1        // But : Fonction Arrivé 
 814   1        // Input : 
 815   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 816   1        // Output : 
 817   1        //    - char : pour vérifier le bon déroulement 
 818   1        // Ajout de la partie Information 
 819   1        strcpy(strings,"ASS ");
 820   1        ptrstrings = &strings[0];
 821   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 822   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Servo_V) {
 823   2          ptrmessage = ajout_char(ptrmessage, 'V');
 824   2        }
 825   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Servo_H) {
 826   2          ptrmessage = ajout_char(ptrmessage, 'H');
 827   2        }
 828   1        return '1';
 829   1      }
 830          
 831          char Convertion_Mesure(char type, char *ptrmessage) {
 832   1        // But : Fonction Mesure
 833   1        // Input : 
 834   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 835   1        // Output : 
 836   1        //    - char : pour vérifier le bo n déroulement 
 837   1        // Ajout de la partie Information 
 838   1        ptrmessage = ajout_char(ptrmessage, 'K');
 839   1        // Cas : Courant 
 840   1        if (type == 'I') {
 841   2          // Ajout de ' ' et valeur 
 842   2          ptrmessage = ajout_char(ptrmessage, type);
 843   2          ptrmessage = ajout_char(ptrmessage, ' ');
 844   2          ptrbuffer = convertion_int_array_M1(informationenvoieAtS.Mesure_Courant);
 845   2          ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 846   2          return 1;
 847   2        }
 848   1        // Cas : Energie
 849   1        if (type == 'E') {
 850   2          // Ajout de ' ' et valeur 
 851   2          ptrmessage = ajout_char(ptrmessage, type);
 852   2          ptrmessage = ajout_char(ptrmessage, ' ');
 853   2          ptrbuffer = convertion_int_array_M1(informationenvoieAtS.Mesure_Energie);
 854   2          ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 855   2          return 1;
C51 COMPILER V9.59.0.0   F0_M1                                                             04/06/2021 12:30:39 PAGE 15  

 856   2        }
 857   1        ptrmessage--;
 858   1        return 0;
 859   1      }
 860          
 861          char Convertion_Info_Obstacle(char *ptrmessage) {
 862   1        // Todo :A comprendre mdrrrr
 863   1        ptrmessage++;
 864   1        return 1;
 865   1      }
 866          
 867          char Convertion_Position(char *ptrmessage, struct INFORMATIONS informationenvoieAS) {
 868   1        strcpy(strings," VPO X:\0");
 869   1        ptrstrings = &strings[0];
 870   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 871   1        ptrbuffer = convertion_int_array_M1(informationenvoieAS.Pos_Coord_X);
 872   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 873   1        
 874   1        strcpy(strings," Y:\0");
 875   1        ptrstrings = &strings[0]; 
 876   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 877   1        ptrbuffer = convertion_int_array_M1(informationenvoieAS.Pos_Coord_Y);
 878   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 879   1        
 880   1        strcpy(strings," A:\0");
 881   1        ptrstrings = &strings[0]; 
 882   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 883   1        ptrbuffer = convertion_int_array_M1(informationenvoieAS.Pos_Angle);
 884   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 885   1        return 1;
 886   1      }
 887          
 888          void prepare_message_random(void) {
 889   1        message_is_ready = 1;
 890   1        informationenvoieAtS.Etat_Invite = Invite_oui ;
 891   1        informationenvoieAtS.MSG_Invit = ptr_asuppr;
 892   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5843    ----
   CONSTANT SIZE    =    103    ----
   XDATA SIZE       =    263     214
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
