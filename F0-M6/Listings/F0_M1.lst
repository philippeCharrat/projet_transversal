C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE F0_M1
OBJECT MODULE PLACED IN .\Objects\F0_M1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE F0_M1.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\F0_M1.lst) TABS(2) OBJECT(.\Objects\F0_M1.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F0-M01.c
   3          //
   4          // Dernière Modification : 15/03/2021 (aucune erreur déclarées et 3 warnings) 
   5          // Auteur : 
   6          //  - Maxime LERICHE
   7          //  - Philippe CHARRAT
   8          // TODO : 
   9          //  - fonction d'erreur 
  10          //  - Convertion Struct to String 
  11          //  - 
  12          //-----------------------------------------------------------------------------
  13          
  14          // Import des bibliothèques ---
  15          #include <C8051F020.h>
  16          #include <stdio.h>
  17          #include <string.h>
  18          #include <stdlib.h>
  19          #include "c8051F020_SFR16.h"
  20          #include "MASTER_Config_Globale.h"
  21          #include "FO_M1__Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
  22          #include "F0_M1.h"
  23          
  24          // ---
  25          
  26          // Prototypes de Fonctions  
  27          // Variables globales utiles
  28          char message_is_set;
  29          int commande_connue;
  30          char message_is_ready;
  31          int j,k,m,fin_commande,analyse_commande;
  32          signed int i;
  33          char bit_reception_UART0;
  34          int iter_M1;
  35          
  36          // Variables char[] 
  37          char xdata buffer[5];
  38          char xdata strings[8];
  39          char xdata commandes_M1[35];
  40          char xdata commande[35];
  41          char xdata params[15];
  42          char xdata message[50];
  43          char xdata message_com[4];
  44          char asuppr[15] = "Test";
  45          char* ptr_asuppr = &asuppr[0];
  46          
  47          // Variables pointeurs 
  48          char* ptrcommande; 
  49          char* ptrcommandes_M1;
  50          char* ptrmessage;
  51          char* ptrbuffer;
  52          char* ptrstrings;
  53          char* ptr_Invite;
  54          
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 2   

  55          struct argument_complexe args;
  56          struct  COMMANDES commandeenvoieStA;
  57          struct  INFORMATIONS informationenvoieAtS;
  58          
  59          //-----------------------------------------------------------------------------
  60          // Fonctions UART et d'envoie
  61          //-----------------------------------------------------------------------------
  62          
  63          
  64          void Send_string_UART0(char* mot){
  65   1        // But : Fonction pour envoyer une string de manière automatique 
  66   1        // Input : 
  67   1        //    - mot : string avec les chars à envoyer (via pointeur)
  68   1        // Output : 
  69   1        //    none
  70   1        // Tant que le char n'est pas la fin de la commande ('\r') 
  71   1        while (*mot != '\0'){
  72   2          if(*(mot+1) == '\r'){ 
  73   3            Transmettre_UART0(*mot, 1); //Fin de chaine 
  74   3          } else { 
  75   3            Transmettre_UART0(*mot, 0); //milieu du mot
  76   3          }
  77   2          mot++;
  78   2        }
  79   1      }
  80          
  81          void Send_char_UART0(char c){
  82   1        // But : Fonction pour envoyer un caractère dans l'UART
  83   1        // Input : 
  84   1        //    - c : caractère à envoyer
  85   1        // Output : 
  86   1        //    none
  87   1        //Desactive reception
  88   1        REN0 = 0;
  89   1        SBUF0 = c;
  90   1        
  91   1        //Attente fin de transmission
  92   1        while(!TI0){}
  93   1          
  94   1        //Remise à 0 du flag d'envoi une fois qu'on est sur que le caractere a été transmis
  95   1        TI0 = 0;
  96   1        REN0 = 1;
  97   1      }
  98          
  99          void Transmettre_UART0(char caractere, bit LF){
 100   1        // But : Fonction pour envoyer un caractère et la 
 101   1        // Input : 
 102   1        //    - caractere : char à envoyer
 103   1        // Output : 
 104   1        //    none
 105   1        EA = 0;
 106   1        //desactive la reception
 107   1        REN0 = 0;
 108   1        
 109   1        //Ecrit la valeur dans SBUF0 pour transmettre
 110   1        SBUF0 = caractere;
 111   1        
 112   1        //Attente de la bonne transmission
 113   1        while(!TI0){}
 114   1          
 115   1        //Remise à 0 du flag d'envoi une fois qu'on est sur que le caractere a été transmis
 116   1        TI0 = 0;
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 3   

 117   1        REN0 = 1;
 118   1          
 119   1        if(LF){Transmettre_UART0(0x0D, 0);
 120   2        Transmettre_UART0(0x0A, 0);} //Retour à la ligne
 121   1        EA = 1;
 122   1      }
 123          
 124          char* split_element_M1(char* ptr_commande) {
 125   1        // But : Récupérer un paramètre (plusieurs char) et les placer dans un tableau globale. La fonction va
             - aussi passer un flag à 1 si la commande est finie ('\r'). 
 126   1        // Input : 
 127   1        //    - *ptr_commande : pointeur vers le buffer de la commande complète. 
 128   1        // Output : 
 129   1        //    - *ptr_commande : pointeur (incrémenté des m caractères parcourus) vers le buffer de la commande c
             -omplète. 
 130   1          m = 0;
 131   1        // Tant que le char n'est pas un espace 
 132   1        while( *ptr_commande != ' ') {
 133   2          // Cas : le char est la fin de la commande  
 134   2          if (*ptr_commande == '\r') {
 135   3            // flag de fin modifié
 136   3            fin_commande = 1;
 137   3            break;
 138   3            // Cas : char est "quelconque"
 139   3          } else {
 140   3            // Ajout dans le tableau params 
 141   3            params[m] = *ptr_commande;
 142   3            params[m+1] = '\0';
 143   3            m++;
 144   3            ptr_commande++;
 145   3          }
 146   2        }
 147   1        // Saut de l'espace 
 148   1        ptr_commande++;
 149   1        return ptr_commande; 
 150   1      }
 151          
 152          struct argument_complexe param_complexe(char* params) {
 153   1        // But : Convertir string en paramètres complexe, forme : param:valeur (exemple : A:12) 
 154   1        // Input : 
 155   1        //    - *param : pointeur vers la string paramètres 
 156   1        // Output : 
 157   1        //    - args : structure composée de deux champs :
 158   1        //          * param : nom du paramètre (1 char) 
 159   1        //          * valeur : entier 
 160   1        // Remarque : Si param plus de 1 char ? Idée : boucle jusqu'à ':'
 161   1        args.param = params[0];
 162   1        args.valeur = int_neg_or_positiv(2, params);
 163   1        return args;
 164   1      }
 165          
 166          int int_neg_or_positiv(int min, char* params) {
 167   1        // But : Gestion du signe pour la convertion str vers int : ['-','1','2'] => -12
 168   1        // Input : 
 169   1        //    - min : int pour indiquer le début du nombre
 170   1        //    - *param : pointeur vers la string contenat les chars 
 171   1        // Output : 
 172   1        //    - i : int signé 
 173   1        // Cas : int négatif 
 174   1        if (params[min] == '-') {
 175   2          // Récupération de sa valeur absolue 
 176   2          i = convertion_str_int_M1(min+1, params);
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 4   

 177   2          // Passage en négatif 
 178   2          i = 0-i;
 179   2          // Cas : int positif
 180   2        } else { i = convertion_str_int_M1(min, params); }
 181   1        return i; 
 182   1      } 
 183          
 184          int convertion_str_int_M1(int k, char* params) {
 185   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 186   1        // Input : 
 187   1        //    - k : int pour indiquer le début du nombre
 188   1        //    - *param : pointeur vers la string contenat les chars 
 189   1        // Output : 
 190   1        //    - atoi(buffer) : int non signé
 191   1        // Remarque : atoi() permet une convertion de char[] en int
 192   1        // Boucle jusqu'à 10 (valeur arbitraire) 
 193   1        for(j=k;j<10; j++){
 194   2          // Si le char est un digit
 195   2          if( params[j] == '1' || params[j] == '2'|| params[j] == '3'|| params[j] == '4'|| params[j] == '5'|| para
             -ms[j] == '6'|| params[j] == '7'|| params[j] == '8'|| params[j] == '9'|| params[j] == '0') {
 196   3            buffer[j-k]=params[j];
 197   3          }
 198   2          else { 
 199   3            buffer[j-k]='\0';
 200   3            break;
 201   3          }
 202   2        }
 203   1        return atoi(buffer);    
 204   1      }
 205          
 206          char* convertion_int_array_M1(int i) {
 207   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 208   1        // Input : 
 209   1        //  - i : int 
 210   1        // Output : 
 211   1        //  - ptr : vers le buffer qui contient les chars
 212   1        k = 0;
 213   1      if (i/1000 != 0) { 
 214   2          buffer[k] = '0'+i/1000;
 215   2          k++;
 216   2          i = i-(i/1000)*1000;
 217   2        
 218   2        } else {
 219   2            buffer[k] = '0';
 220   2          k++;
 221   2        }
 222   1        if (i/100 != 0) { 
 223   2          buffer[k] = '0'+i/100;
 224   2          k++;
 225   2          i = i-(i/100)*100;
 226   2        } else {
 227   2            buffer[k] = '0';
 228   2          k++;
 229   2        } 
 230   1        if (i/10 != 0) { 
 231   2          buffer[k] = '0'+i/10;
 232   2          i = i-(i/10)*10;
 233   2          k++;
 234   2        } else {
 235   2            buffer[k] = '0';
 236   2          k++;
 237   2        }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 5   

 238   1        if (i != 0) { 
 239   2          buffer[k] = '0'+i;
 240   2          k++;
 241   2        } else {
 242   2            buffer[k] = '0';
 243   2          k++;
 244   2        }
 245   1        buffer[k] = '\0';
 246   1        return &buffer[0];
 247   1      }
 248          
 249          char* ajout_char_array(char* ptrbuffer, char* ptrmessage) {
 250   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 251   1        // Input : 
 252   1        //    - *ptrmessage : pointeur vers le message
 253   1        //    - *ptrbuffer : pointeur vers le buffer de int
 254   1        // Output : 
 255   1        //    none
 256   1        while (1==1){
 257   2          // Si le char est un digit
 258   2          if( *ptrbuffer == '1' || *ptrbuffer == '2'|| *ptrbuffer == '3'|| *ptrbuffer == '4'|| *ptrbuffer == '5'||
             - *ptrbuffer == '6'|| *ptrbuffer == '7'|| *ptrbuffer == '8'|| *ptrbuffer == '9'|| *ptrbuffer == '0') {
 259   3            ptrmessage = ajout_char(ptrmessage, *ptrbuffer);
 260   3            ptrbuffer++;
 261   3          }
 262   2          else { 
 263   3            return ptrmessage;
 264   3          }
 265   2        }
 266   1      }
 267          
 268          char* ajout_char_string(char* ptrstrings, char* ptrmessage) {
 269   1        // But : Convertir plusieurs chars vers un int (absolue) : ['1','2'] => 12
 270   1        // Input : 
 271   1        //    - *ptrmessage : pointeur vers le message
 272   1        //    - *ptrbuffer : pointeur vers le buffer de int
 273   1        // Output : 
 274   1        //    none
 275   1        while (1==1){
 276   2          // Si le char est un digit
 277   2          if( *ptrstrings != '\0') {
 278   3            ptrmessage = ajout_char(ptrmessage, *ptrstrings);
 279   3            ptrstrings++;
 280   3          }
 281   2          else { 
 282   3            return ptrmessage;
 283   3          }
 284   2        }
 285   1      }
 286          
 287          char* ajout_char(char* ptrmessage, char c) {
 288   1        // But : Ajout d'un char sur message
 289   1        // Input : 
 290   1        //    - ptrmessage : pointeur vers le message
 291   1        //    - char : char à ajouter 
 292   1        // Output : 
 293   1        //    - ptrmessage : pointeur incrémenté
 294   1        *ptrmessage = c;
 295   1        ++ptrmessage;
 296   1        //*ptrmessage = '\0';
 297   1        return ptrmessage;
 298   1      }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 6   

 299          
 300          struct COMMANDES recuperation_structure_commande(struct COMMANDES pCommandeenvoieStA)
 301          {
 302   1        // Partie Réception 
 303   1        if (RI0 == 1){
 304   2          commandeenvoieStA = pCommandeenvoieStA;
 305   2          RI0 = 0;
 306   2          REN0 = 0;
 307   2          // Récupération du char dans le buffer
 308   2          bit_reception_UART0 = SBUF0;
 309   2          // Ajout du char dans la string commande 
 310   2          commandes_M1[iter_M1] = bit_reception_UART0;
 311   2          commandes_M1[iter_M1+1] = '\0';
 312   2          Send_char_UART0(bit_reception_UART0);
 313   2          // Incrément du tab commande
 314   2          iter_M1++;
 315   2          // Si fin de commande 
 316   2          if (bit_reception_UART0 == '\r'){
 317   3            // Affichage en console
 318   3            Send_string_UART0("Commande recue : ");
 319   3            Send_string_UART0(commandes_M1);
 320   3            ptrcommandes_M1 = &commandes_M1[0];
 321   3            
 322   3            // Convertion de commande vers struct
 323   3            pCommandeenvoieStA = Convertion_S_to_A(ptrcommandes_M1);
 324   3            iter_M1 = 0;
 325   3          }
 326   2        }
 327   1        return pCommandeenvoieStA;
 328   1      }
 329          
 330          //-----------------------------------------------------------------------------
 331          // Fonctions Convertion String vers Structure
 332          //-----------------------------------------------------------------------------
 333          
 334          struct COMMANDES Convertion_S_to_A(char * ptrcommande) {
 335   1        // But : Récupérer la partie commande et appeler les fonctions correspondante
 336   1        // Input : 
 337   1        //    none
 338   1        // Output : 
 339   1        //    none
 340   1        // Remarque : strcmp() permet de chercher une suite de char dans un autre.
 341   1        // Remarque : A vérifier que je n'ai pas oublier de fonction comme le son ou MOU ... 
 342   1        
 343   1        // Récupération de la partie commande dans le tableau params
 344   1        ptrcommande = split_element_M1(ptrcommande);
 345   1        commande_connue = 1;
 346   1        fin_commande = 0;
 347   1        analyse_commande = 0;
 348   1        
 349   1        // Test des différents cas de figures 
 350   1        if (params[0] == 'D' || params[0] == 'E' || params[0] == 'Q') {
 351   2            Convertion_Etat(params[0],ptrcommande);
 352   2        } else if (strcmp(params, "ASS") == 0) { 
 353   2            Convertion_Sonore(ptrcommande);
 354   2        } else if (strcmp(params, "MOB") == 0 ) {
 355   2            Convertion_Detection(ptrcommande);
 356   2        } else if (strcmp(params, "CS") == 0) {
 357   2            Convertion_Servomoteur(ptrcommande);
 358   2        } else if (strcmp(params, "MI") == 0 || strcmp(params, "ME") == 0 ) {
 359   2            if (strcmp(params, "MI") == 0) {  commandeenvoieStA.Etat_Energie = Mesure_I; }
 360   2            else { commandeenvoieStA.Etat_Energie = Mesure_E;}
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 7   

 361   2        }else if (strcmp(params, "IPO") == 0 || strcmp(params, "POS") == 0) {
 362   2            Convertion_Coord(params,ptrcommande);
 363   2        } else if (strcmp(params, "L") == 0 || strcmp(params, "LS") == 0 ) {
 364   2            Convertion_Lumineux(params, ptrcommande);
 365   2        }else if (strcmp(params, "PPH") == 0 || strcmp(params, "SPH") == 0 ) {
 366   2            Convertion_Photo(params, ptrcommande);
 367   2        } else if (params[0] == 'A' || params[0] == 'B' || params[0] == 'S' || strcmp(params, "RD") == 0 || strcm
             -p(params, "RG") == 0 || strcmp(params, "RC") == 0 || strcmp(params, "RA") == 0|| strcmp(params, "TV") == 0) {
 368   2          if (commandeenvoieStA.Etat_Mouvement != Depl_Coord){
 369   3            Convertion_Mouvement(params,ptrcommande);}
 370   2        } else if (params[0] == 'G'){
 371   2            Convertion_Coord_Init(ptrcommande);
 372   2        } else {
 373   2            commande_connue = 0;
 374   2        }
 375   1        
 376   1        // Partie Réponse : 
 377   1        memset(message_com,0,10);
 378   1        ptrmessage = &message_com[0];
 379   1        ptrmessage = ajout_char(ptrmessage, 0x0D);
 380   1        ptrmessage = ajout_char(ptrmessage, 0x0A);
 381   1        if (commande_connue == 1) { ptrmessage = ajout_char(ptrmessage, 0x3E);  }
 382   1        else {  ptrmessage = ajout_char(ptrmessage, 0x23); }
 383   1        ptrmessage = ajout_char(ptrmessage, '\r');
 384   1        Send_string_UART0(&message_com[0]);
 385   1          
 386   1        return commandeenvoieStA;
 387   1      } 
 388             
 389          void Convertion_Etat(char etat, char* ptrcommande) {
 390   1        // But : Fonction pour les modifications de l'état d'épreuve
 391   1        // Input : 
 392   1        //    - etat : char qui définie l'état 
 393   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 394   1        // Output : 
 395   1        //    none
 396   1        // Cas D : Commencez étape 
 397   1          
 398   1        if (etat == 'D') {
 399   2          // Valeur par défaut 
 400   2          commandeenvoieStA.Etat_Epreuve = epreuve1;
 401   2          // Récupération et convertion de l'étape : 
 402   2          ptrcommande = split_element_M1(ptrcommande);
 403   2          
 404   2          i = int_neg_or_positiv(0,params);
 405   2          // Modification de la structure en fonction 
 406   2          if ( i == 1 ) { commandeenvoieStA.Etat_Epreuve = epreuve1;  }
 407   2          else if ( i == 2 ) {commandeenvoieStA.Etat_Epreuve = epreuve2;}
 408   2          else if ( i == 3 ) {commandeenvoieStA.Etat_Epreuve = epreuve3;}
 409   2          else if ( i == 4 ) {commandeenvoieStA.Etat_Epreuve = epreuve4;}
 410   2          else if ( i == 5 ) {commandeenvoieStA.Etat_Epreuve = epreuve5;}
 411   2          else if ( i == 6 ) {commandeenvoieStA.Etat_Epreuve = epreuve6;}
 412   2          else if ( i == 7 ) {commandeenvoieStA.Etat_Epreuve = epreuve7;}
 413   2          else if ( i == 8 ) {commandeenvoieStA.Etat_Epreuve = epreuve8;}
 414   2          // Cas E : Fin de l'épreuve 
 415   2        } else if (etat == 'E') {commandeenvoieStA.Etat_Epreuve = Fin_Epreuve; }
 416   1        // Cas Q : Arrêt de l'épreuve
 417   1        else { commandeenvoieStA.Etat_Epreuve = Stop_Urgence; }
 418   1      }
 419          
 420          void Convertion_Mouvement(char *mouvement, char* ptrcommande) {
 421   1        // But : Fonction de gestion des mouvements
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 8   

 422   1        // Input : 
 423   1        //    - *mouvement : pointeur pour connaitre le type de mouvement 
 424   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 425   1        // Output : 
 426   1        //    none
 427   1        // Cas : Modification vitesse 
 428   1        if (strcmp(mouvement, "TV") == 0) {
 429   2                // Récupération du premier paramètre
 430   2              ptrcommande = split_element_M1(ptrcommande);
 431   2              j = int_neg_or_positiv(0, params);
 432   2              if (j > 5 && j< 100) { 
 433   3                commandeenvoieStA.Vitesse = j;  
 434   3              }
 435   2        // Cas : Avancer ou reculer
 436   2        } else if (mouvement[0] == 'A'|| mouvement[0] == 'B') {
 437   2              // Modification de la structure avec l'action 
 438   2              if (mouvement[0] == 'A') { commandeenvoieStA.Etat_Mouvement = Avancer; }
 439   2              else { commandeenvoieStA.Etat_Mouvement = Reculer; }
 440   2              if (fin_commande == 0) {
 441   3                ptrcommande = split_element_M1(ptrcommande);
 442   3                // Convertion du param
 443   3                j = int_neg_or_positiv(0, params);
 444   3                // Modification de la vitesse
 445   3                if (j > 5 && j<100) {commandeenvoieStA.Vitesse = j; }
 446   3              }
 447   2              if (commandeenvoieStA.Vitesse == 0) {commandeenvoieStA.Vitesse = 20;}
 448   2        // Cas : Stop le mouvement
 449   2        } else if (mouvement[0]== 'S') {
 450   2            commandeenvoieStA.Etat_Mouvement = Stopper;
 451   2        // Cas : Tourner à droite de 90° 
 452   2        } else if (strcmp(mouvement, "RD") == 0) {
 453   2            commandeenvoieStA.Etat_Mouvement = Rot_90D;
 454   2        // Cas : Tourner à gauche de 90°
 455   2        } else if (strcmp(mouvement, "RG") == 0) {
 456   2            commandeenvoieStA.Etat_Mouvement = Rot_90G;
 457   2        // Cas : Rotation de 180°
 458   2        } else if (strcmp(mouvement, "RC") == 0) {
 459   2            commandeenvoieStA.Etat_Mouvement = Rot_180D;
 460   2            if (fin_commande == 0) {
 461   3              ptrcommande = split_element_M1(ptrcommande);
 462   3              // Cas : Droite 
 463   3              if (params[0] == 'D') { commandeenvoieStA.Etat_Mouvement = Rot_180D; }
 464   3              // Cas : Gauche
 465   3              else if (params[0] == 'G'){ commandeenvoieStA.Etat_Mouvement = Rot_180G; }
 466   3            }
 467   2            // Cas : Rotation d'un angle
 468   2        } else if (strcmp(mouvement, "RA") == 0) {
 469   2              // Valeurs par défaut 
 470   2              commandeenvoieStA.Etat_Mouvement =Rot_AngD;
 471   2              commandeenvoieStA.Angle = 90; 
 472   2            if (fin_commande == 0) {
 473   3              ptrcommande = split_element_M1(ptrcommande);
 474   3              // Convertion du param en struct
 475   3              if (params[1] == ':') {
 476   4                args = param_complexe(params);
 477   4                // Cas : Droite ou Gauche
 478   4                if (args.param == 'D') {commandeenvoieStA.Etat_Mouvement =Rot_AngD; }
 479   4                else if (args.param == 'G'){commandeenvoieStA.Etat_Mouvement =Rot_AngG;}
 480   4                // Ajout de l'angle
 481   4                commandeenvoieStA.Angle = args.valeur;
 482   4            }
 483   3          }
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 9   

 484   2        } 
 485   1      }     
 486          
 487          void Convertion_Coord_Init(char* ptrcommande)
 488          {
 489   1        while (fin_commande == 0) {
 490   2          // Récupérations et convertions des paramètres 
 491   2          ptrcommande = split_element_M1(ptrcommande);
 492   2          // Si l'argument est complexe
 493   2          if (params[1] == ':') {
 494   3            args = param_complexe(params);
 495   3            // Différents cas possibles 
 496   3            if ( args.param == 'X') {
 497   4              if ( args.valeur > -99 && args.valeur < 99) {
 498   5                commandeenvoieStA.Coord_X = args.valeur;
 499   5              }
 500   4            } else if ( args.param == 'Y') {
 501   4              if ( args.valeur > -99 && args.valeur < 99) {
 502   5                commandeenvoieStA.Coord_Y = args.valeur;
 503   5              }
 504   4            } else if ( args.param == 'A') {
 505   4              if ( args.valeur > -180 && args.valeur < 180) {
 506   5                commandeenvoieStA.Angle = args.valeur;
 507   5              }
 508   4            }
 509   3          }
 510   2        } 
 511   1      }
 512          
 513          void  Convertion_Sonore(char* ptrcommande){ 
 514   1        // But : Modification de l'état sonore
 515   1        // Input : 
 516   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 517   1        // Output : 
 518   1        //    none
 519   1        // Valeurs par défauts
 520   1        ptrcommande = split_element_M1(ptrcommande);
 521   1            if (*ptrcommande == '0') { commandeenvoieStA.Etat_ACQ_Son = ACQ_non; }
 522   1            else {
 523   2              commandeenvoieStA.Etat_ACQ_Son = ACQ_oui;
 524   2                i = int_neg_or_positiv(0, params);
 525   2                if (i > 0 && i < 100) { commandeenvoieStA.ACQ_Duree = i; }
 526   2                else { commandeenvoieStA.ACQ_Duree = 99; }
 527   2            }
 528   1          }
 529          void Convertion_Detection(char* ptrcommande) {
 530   1        // But : Fonction de gestion de la détection d'obstacle
 531   1        // Input : 
 532   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 533   1        // Output : 
 534   1        //    none
 535   1        // Valeurs par défauts
 536   1        commandeenvoieStA.DCT_Obst_Resolution = 30;
 537   1        commandeenvoieStA.Etat_DCT_Obst = oui_360;
 538   1        // Boucle des paramètres
 539   1        while (fin_commande == 0) {
 540   2          // Récupération du paramètre
 541   2          ptrcommande = split_element_M1(ptrcommande);
 542   2          // Cas : Angle détection
 543   2          if( params[0] == '1' || params[0] == '0'|| params[0] == '2') {
 544   3            i = int_neg_or_positiv(0, params);
 545   3            if (i == 0) { commandeenvoieStA.Etat_DCT_Obst = DCT_non;}
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 10  

 546   3            else if (i == 1) {commandeenvoieStA.Etat_DCT_Obst = oui_180;}
 547   3            else {commandeenvoieStA.Etat_DCT_Obst = oui_360;}
 548   3          }
 549   2          // Cas :Résolution angulaire
 550   2          if (params[0] == 'A' ) {
 551   3            args = param_complexe(params);
 552   3            if (args.valeur > 5 && args.valeur < 45) {commandeenvoieStA.DCT_Obst_Resolution = args.valeur;}
 553   3            else { commandeenvoieStA.DCT_Obst_Resolution = 30; }
 554   3          } 
 555   2        }
 556   1      }
 557          void Convertion_Servomoteur(char* ptrcommande) {  
 558   1        // But : Fonction de gestion des servomoteurs
 559   1        // Input : 
 560   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 561   1        // Output : 
 562   1        //    none
 563   1        // Valeurs par défauts
 564   1        commandeenvoieStA.Servo_Angle = 0;
 565   1        commandeenvoieStA.Etat_Servo = Servo_H;
 566   1        // Tant que l'on a des paramètres : 
 567   1        while (fin_commande == 0) {
 568   2          // Récupération des paramètres
 569   2          ptrcommande = split_element_M1(ptrcommande);
 570   2          
 571   2          // Cas : Servomoteur Horizontale
 572   2          if (params[0] == 'H') { commandeenvoieStA.Etat_Servo = Servo_H; }
 573   2          // Cas : Servomoteur Verticale
 574   2          if (params[0] == 'V') { 
 575   3            commandeenvoieStA.Etat_Servo = Servo_V; }
 576   2          // Ajout de l'angle
 577   2          if (params[0] == 'A') {
 578   3            args = param_complexe(params);  
 579   3            commandeenvoieStA.Servo_Angle = args.valeur;
 580   3          }
 581   2        }
 582   1      }
 583          
 584          void Convertion_Coord(char* params,char* ptrcommande) { 
 585   1        // But : Fonction de gestion des coordonnées
 586   1        // Input : 
 587   1        //    - *params : pointeur vers le type de commande
 588   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 589   1        // Output : 
 590   1        //    none
 591   1        // Cas : Initialisation de coord
 592   1        if (strcmp(params, "IPO") == 0) {
 593   2          // Valeurs par défaults
 594   2          commandeenvoieStA.Etat_Position = Init_Position;
 595   2          commandeenvoieStA.Pos_Angle = 0;
 596   2          // Boucle pour récupérer les paramètres
 597   2          while (fin_commande == 0) {
 598   3            // Récupération des paramètres
 599   3            ptrcommande = split_element_M1(ptrcommande);
 600   3            args = param_complexe(params);
 601   3            // Différents cas : 
 602   3            if ( args.param == 'X') { commandeenvoieStA.Pos_Coord_X = args.valeur; } 
 603   3            if ( args.param == 'Y') { commandeenvoieStA.Pos_Coord_Y = args.valeur; }
 604   3            if ( args.param == 'A') { commandeenvoieStA.Pos_Angle = args.valeur; }
 605   3          }
 606   2          // Sinon : Récupération de coord
 607   2        } else {commandeenvoieStA.Etat_Position = Demande_Position;}      
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 11  

 608   1      }
 609          
 610          void Convertion_Lumineux(char* params, char* ptrcommande) {
 611   1        // But : Fonction de gestion du pointeur lumineux
 612   1        // Input : 
 613   1        //    - *mouvement : pointeur pour connaitre le type de commandes_M1 
 614   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 615   1        // Output : 
 616   1        //    none
 617   1        // Cas : Fin  
 618   1        if (strcmp(params, "LS") == 0) {
 619   2          commandeenvoieStA.Etat_Lumiere = Eteindre;
 620   2          // Cas : Initialisation 
 621   2        } else {
 622   2          // Valeurs par défaults
 623   2          commandeenvoieStA.Etat_Lumiere = Allumer;
 624   2          commandeenvoieStA.Lumiere_Intensite = 100;      
 625   2          commandeenvoieStA.Lumiere_Duree = 99;
 626   2          commandeenvoieStA.Lumire_Extinction = 0;
 627   2          commandeenvoieStA.Lumiere_Intensite = 1;
 628   2          // Boucle pour récupérer les paramètres 
 629   2          while (fin_commande == 0) {
 630   3            // Récupérations et convertions des paramètres 
 631   3            ptrcommande = split_element_M1(ptrcommande);
 632   3            // Si l'argument est complexe
 633   3            if (params[1] == ':') {
 634   4              args = param_complexe(params);
 635   4              // Différents cas possibles 
 636   4              if ( args.param == 'I') {
 637   5                if ( args.valeur > 0 && args.valeur < 101) {
 638   6                  commandeenvoieStA.Lumiere_Intensite = args.valeur;
 639   6                }
 640   5              } else if ( args.param == 'D') {
 641   5                if ( args.valeur > 0 && args.valeur < 101) {
 642   6                  commandeenvoieStA.Lumiere_Duree = args.valeur;
 643   6                }
 644   5              } else if ( args.param == 'E') {
 645   5                if ( args.valeur > 0 && args.valeur < 101) {
 646   6                  commandeenvoieStA.Lumire_Extinction = args.valeur;
 647   6                }
 648   5              } else if ( args.param == 'N') {
 649   5                if ( args.valeur > 0 && args.valeur < 101) {
 650   6                  commandeenvoieStA.Lumiere_Nbre = args.valeur;
 651   6                }
 652   5              }
 653   4              
 654   4            } // Sinon, ignoré
 655   3          }
 656   2        }
 657   1      }
 658          
 659          void Convertion_Photo(char* params, char* ptrcommande) {
 660   1        // But : Fonction de gestion des photos
 661   1        // Input : 
 662   1        //    - *params : pointeur pour connaitre le type de commandes_M1 
 663   1        //    - *ptrcommande : pointeur vers les paramètres possibles 
 664   1        // Output : 
 665   1        //    none
 666   1        // Cas : Initialisation  
 667   1        if (strcmp(params, "PPH") == 0) {
 668   2          // Valeurs par défaut 
 669   2          commandeenvoieStA.Etat_Photo = Photo_1;
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 12  

 670   2          commandeenvoieStA.Photo_Duree = 1;
 671   2          commandeenvoieStA.Photo_Nbre = 1;
 672   2          
 673   2          while (fin_commande == 0) {
 674   3            // Récupérations et convertions des paramètres 
 675   3            ptrcommande = split_element_M1(ptrcommande);
 676   3            // Différents cas possibles 
 677   3            if ( params[0] == 'O') {
 678   4              commandeenvoieStA.Etat_Photo = Photo_1;
 679   4            }
 680   3            if ( params[0] == 'S') {
 681   4              commandeenvoieStA.Etat_Photo = Photo_Multiple; 
 682   4            }
 683   3            if ( params[0] == 'E') {
 684   4              args = param_complexe(params);
 685   4              commandeenvoieStA.Photo_Duree = args.valeur;
 686   4            }
 687   3            if ( params[0] == 'N') {
 688   4              args = param_complexe(params);
 689   4              commandeenvoieStA.Photo_Nbre = args.valeur;
 690   4            }
 691   3          }
 692   2          // Cas : Fin de photo
 693   2        } else {
 694   2            commandeenvoieStA.Etat_Photo = Photo_stop;
 695   2        }
 696   1      }
 697          
 698          //-----------------------------------------------------------------------------
 699          // Fonctions Convertion Structure vers String
 700          //-----------------------------------------------------------------------------
 701          
 702          void Convertion_A_to_S(struct INFORMATIONS informationenvoieAS) {
 703   1        // But : Convertion de la structure en string
 704   1        // Input : 
 705   1        //    none
 706   1        // Output : 
 707   1        //    none
 708   1        // Initialisation des variables
 709   1        message_is_set = 0;
 710   1        memset(message,0,30);
 711   1        ptrmessage = &message[0];
 712   1        // Différents cas possible 
 713   1        // Si le message en lien avec l'état 
 714   1        if (informationenvoieAS.Etat_Invite == Invite_oui && message_is_set==0) {
 715   2          message_is_set= Convertion_Invite(ptrmessage,informationenvoieAS);
 716   2          
 717   2        }
 718   1        // Si le message en lien avec l'arrivé
 719   1        if (informationenvoieAS.Etat_BUT_Mouvement == BUT_Atteint_oui && message_is_set==0) {
 720   2          message_is_set= Convertion_Arrive(ptrmessage); 
 721   2        }
 722   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Atteint_oui && message_is_set==0) {
 723   2          message_is_set= Convertion_Arrive_Servo(ptrmessage,informationenvoieAS); 
 724   2        }
 725   1        // Si le message en lien avec le courant
 726   1        if (informationenvoieAS.Etat_RESULT_Courant == RESULT_Courant_oui && message_is_set==0) {
 727   2          message_is_set=Convertion_Mesure('I',ptrmessage);
 728   2        }
 729   1        // Si le message en lien avec l'énergie
 730   1        if (informationenvoieAS.Etat_RESULT_Energie == RESULT_Energie_oui && message_is_set==0) {
 731   2          message_is_set=Convertion_Mesure('E',ptrmessage);
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 13  

 732   2        }
 733   1        // Si le message en lien avec l'angle
 734   1        if (informationenvoieAS.Etat_RESULT_Position == RESULT_Position_oui && message_is_set==0) {
 735   2          
 736   2          message_is_set=Convertion_Position(ptrmessage, informationenvoieAS);
 737   2        }
 738   1        // Si le message est initialisé
 739   1        if (message_is_set=='1') {
 740   2          ptrmessage = ajout_char(ptrmessage, '\n');
 741   2          ptrmessage = ajout_char(ptrmessage, '\r');
 742   2          Send_string_UART0(&message[0]);
 743   2        }
 744   1      } 
 745          
 746          char Convertion_Invite(char *ptrmessage,struct INFORMATIONS informationenvoieAS) {
 747   1        // But : Fonction Invité de Commande
 748   1        // Input : 
 749   1        //    - *ptrmessage : pointeur vers le char[] pour le message
 750   1        // Output : 
 751   1        //    - char : pour vérifier le bodéroulement 
 752   1        // Ajout de la partie Information 
 753   1        ptrmessage = ajout_char(ptrmessage, 'I');
 754   1        ptrmessage = ajout_char(ptrmessage, ' '); 
 755   1        strcat(message,informationenvoieAS.MSG_Invit);
 756   1        
 757   1        
 758   1        return '1';
 759   1      }
 760          
 761          char Convertion_Arrive(char *ptrmessage) {
 762   1        // But : Fonction Arrivé 
 763   1        // Input : 
 764   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 765   1        // Output : 
 766   1        //    - char : pour vérifier le bon déroulement 
 767   1        // Ajout de la partie Information 
 768   1        ptrmessage = ajout_char(ptrmessage, 'B');
 769   1        return '1';
 770   1      }
 771          
 772          char Convertion_Arrive_Servo(char *ptrmessage, struct INFORMATIONS informationenvoieAS) {
 773   1        // But : Fonction Arrivé 
 774   1        // Input : 
 775   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 776   1        // Output : 
 777   1        //    - char : pour vérifier le bon déroulement 
 778   1        // Ajout de la partie Information 
 779   1        strcpy(strings,"ASS ");
 780   1        ptrstrings = &strings[0];
 781   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 782   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Servo_V) {
 783   2          ptrmessage = ajout_char(ptrmessage, 'V');
 784   2        }
 785   1        if (informationenvoieAS.Etat_BUT_Servo == BUT_Servo_H) {
 786   2          ptrmessage = ajout_char(ptrmessage, 'H');
 787   2        }
 788   1        return '1';
 789   1      }
 790          
 791          char Convertion_Mesure(char type, char *ptrmessage) {
 792   1        // But : Fonction Mesure
 793   1        // Input : 
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 14  

 794   1        //    - *ptrmessage : pointeur vers le char[] poour le message
 795   1        // Output : 
 796   1        //    - char : pour vérifier le bo n déroulement 
 797   1        // Ajout de la partie Information 
 798   1        ptrmessage = ajout_char(ptrmessage, 'K');
 799   1        // Cas : Courant 
 800   1        if (type == 'I') {
 801   2          // Ajout de ' ' et valeur 
 802   2          ptrmessage = ajout_char(ptrmessage, type);
 803   2          ptrmessage = ajout_char(ptrmessage, ' ');
 804   2          ptrbuffer = convertion_int_array_M1(informationenvoieAtS.Mesure_Courant);
 805   2          ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 806   2          return 1;
 807   2        }
 808   1        // Cas : Energie
 809   1        if (type == 'E') {
 810   2          // Ajout de ' ' et valeur 
 811   2          ptrmessage = ajout_char(ptrmessage, type);
 812   2          ptrmessage = ajout_char(ptrmessage, ' ');
 813   2          ptrbuffer = convertion_int_array_M1(informationenvoieAtS.Mesure_Energie);
 814   2          ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 815   2          return 1;
 816   2        }
 817   1        ptrmessage--;
 818   1        return 0;
 819   1      }
 820          
 821          char Convertion_Info_Obstacle(char *ptrmessage) {
 822   1        // Todo :A comprendre mdrrrr
 823   1        ptrmessage++;
 824   1        return 1;
 825   1      }
 826          
 827          char Convertion_Position(char *ptrmessage, struct INFORMATIONS informationenvoieAS) {
 828   1        strcpy(strings," VPO X:\0");
 829   1        ptrstrings = &strings[0];
 830   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 831   1        ptrbuffer = convertion_int_array_M1(informationenvoieAS.Pos_Coord_X);
 832   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 833   1        
 834   1        strcpy(strings," Y:\0");
 835   1        ptrstrings = &strings[0]; 
 836   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 837   1        ptrbuffer = convertion_int_array_M1(informationenvoieAS.Pos_Coord_Y);
 838   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 839   1        
 840   1        strcpy(strings," A:\0");
 841   1        ptrstrings = &strings[0]; 
 842   1        ptrmessage = ajout_char_string(ptrstrings, ptrmessage);
 843   1        ptrbuffer = convertion_int_array_M1(informationenvoieAS.Pos_Angle);
 844   1        ptrmessage = ajout_char_array(ptrbuffer,ptrmessage);
 845   1        return 1;
 846   1      }
 847          
 848          void prepare_message_random(void) {
 849   1        message_is_ready = 1;
 850   1        informationenvoieAtS.Etat_Invite = Invite_oui ;
 851   1        informationenvoieAtS.MSG_Invit = ptr_asuppr;
 852   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.59.0.0   F0_M1                                                             04/05/2021 16:58:02 PAGE 15  

   CODE SIZE        =   5552    ----
   CONSTANT SIZE    =     95    ----
   XDATA SIZE       =    263     214
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
